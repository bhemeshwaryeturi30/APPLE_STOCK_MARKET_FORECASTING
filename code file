OperationalMetric.sql code:
SELECT * FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD

RTS_Weekly_Task_Part1_Data_Prep.sql code:
CREATE OR REPLACE PROCEDURE Return_to_stock_Data_Prep_Procedure()
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
FISCAL_WEEK_START INT;
FISCAL_WEEK_END INT;
START_DATE DATE;
END_DATE DATE;

BEGIN

--CREATING A STANDARDIZED RETURN TO STOCK RATE QUERY - DATA PREPARATION PHASE
--PART 1: PREPARES BASE DATA AND FISCAL WEEK CALCULATIONS

--PLACE THE FISCAL WEEK NUMBERS TO LOOK AT 
--GRABBING THE MINIMUM AND MAXIMUM FISCAL WEEK NUMBERS THAT THIS GETS SET OVER.

CREATE OR REPLACE TEMPORARY TABLE FISCAL_WEEK_START_AND_END AS ( 
SELECT 
    MIN(FISCAL_WEEK_NBR) AS FISCAL_WEEK
FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
WHERE 
    START_DT > CURRENT_DATE() - 372
UNION 
SELECT 
    MAX(FISCAL_WEEK_NBR) AS FISCAL_WEEK 
FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
WHERE 
    END_DT <= CURRENT_DATE()
);

-- Assigning values to the variables from the temporary table
SELECT MIN(FISCAL_WEEK) INTO FISCAL_WEEK_START FROM FISCAL_WEEK_START_AND_END;
SELECT MAX(FISCAL_WEEK) INTO FISCAL_WEEK_END FROM FISCAL_WEEK_START_AND_END;

CREATE OR REPLACE TEMPORARY TABLE FISCAL_WEEK_START_TB AS ( 
SELECT 
      MIN(START_DT) AS START_DT
    , MAX(END_DT)   AS END_DT
FROM (
SELECT 
      START_DT 
    , END_DT 
    , FISCAL_WEEK_NBR
FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
WHERE FISCAL_WEEK_NBR BETWEEN :FISCAL_WEEK_START AND :FISCAL_WEEK_END)
);

SELECT START_DT INTO START_DATE FROM FISCAL_WEEK_START_TB;
SELECT END_DT INTO END_DATE FROM FISCAL_WEEK_START_TB;

-- ----------------------------------------------------------------- 
-- ---------GETTING ALL RX WITH THE WAITING BIN STATUS--------------
-- ----------------------------------------------------------------- 
CREATE OR REPLACE TEMPORARY TABLE WAITING_BIN_STATUS_ONE AS ( 
SELECT DISTINCT
      RX_NBR 
    , STORE_NBR 
    , FILL_NBR
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PF 
--encompass these three statuses (WB, SOLD, RTS). Have seen scripts only have a sold status and no WB status.
WHERE 
    FILL_STATUS_CD IN (6,7,9) 
    AND CAST(PRESCRIPTION_FILL_TS AS DATE) > DATEADD(MONTH, -6, :START_DATE) 
);

CREATE OR REPLACE TEMPORARY TABLE WAITING_BIN_STATUS_TWO AS (
SELECT DISTINCT
      RX_NBR 
    , STORE_NBR  
    , FILL_NBR
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_HISTORY
WHERE 
    FILL_STATUS_CD IN (6,7,9) 
    AND PRESCRIPTION_FILL_TS > DATEADD(MONTH, -6, :START_DATE) 
);

CREATE OR REPLACE TEMPORARY TABLE BASE_RX AS (
SELECT 
      RX_NBR 
    , STORE_NBR 
    , FILL_NBR
FROM WAITING_BIN_STATUS_ONE 
UNION 
SELECT  
       RX_NBR
     , STORE_NBR
     , FILL_NBR
FROM WAITING_BIN_STATUS_TWO
);

-- ------------------------------------------------------------------- 
-- ---------GRABBING THE QV2 DATE/TIMESTAMP FOR THESE RX--------------
-- ------------------------------------------------------------------- 
-- --The QV2 Date will be considered to be the date that the Rx was placed in WB.
CREATE OR REPLACE TEMPORARY TABLE FINAL_VERIFICATION AS ( 
SELECT DISTINCT
        BASE.RX_NBR 
      , BASE.STORE_NBR 
      , BASE.FILL_NBR 
      , CAST(PACT.REC_EFF_TS AS DATE) AS QV2_DATE
FROM BASE_RX AS BASE
JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_XREF AS X 
    ON BASE.RX_NBR = X.RX_NBR 
    AND BASE.STORE_NBR = X.STORE_NBR 
    AND BASE.FILL_NBR = X.FILL_NBR 
JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_ACTIVITY AS PACT 
    ON X.RXC_PRESCRIPTION_FILL_ID = PACT.RXC_PRESCRIPTION_FILL_ID
WHERE 
    ACTIVITY_CD IN (4) --QV2
    AND TO_DATE(PACT.REC_EFF_TS) >= DATEADD(WEEK, -4, :START_DATE)
); 

-- -------------------------------------------------------------------
-- --------GRABBING THE RETURN TO STOCK INVENTORY---------------------
-- -------------------------------------------------------------------
-- --THESE DATES WILL BE UTILIZED FOR THE NUMERATOR IN THE EQUATION.
CREATE OR REPLACE TEMPORARY TABLE RETURN_TO_STOCK AS (
SELECT DISTINCT
      CAST(CREATE_TS AS DATE) AS RTS_DATE
    , RTS.STORE_NBR 
    , DELETED_RX_NBR 
    , DELETED_FILL_NBR 
    , ROW_NUMBER()OVER(PARTITION BY RTS.STORE_NBR, RTS.DELETED_RX_NBR, RTS.DELETED_FILL_NBR ORDER BY REC_EFF_TS) AS RTS_EVENT_ORDER
FROM CORE_RX.CURATED_SCRIPT.RTS_INVENTORY_EVENT_DETAIL AS RTS 
WHERE 
    TO_DATE(RTS.REC_EFF_TS) >= DATEADD(WEEK, -4, :START_DATE)
);

-- Store prepared data in persistent temporary tables for the next procedure
CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_BASE_RX AS (
SELECT * FROM BASE_RX
);

CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FINAL_VERIFICATION AS (
SELECT * FROM FINAL_VERIFICATION
);

CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_RETURN_TO_STOCK AS (
SELECT * FROM RETURN_TO_STOCK
);

-- Store fiscal week parameters for the next procedure
CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FISCAL_PARAMS AS (
SELECT 
    :FISCAL_WEEK_START AS FISCAL_WEEK_START,
    :FISCAL_WEEK_END AS FISCAL_WEEK_END,
    :START_DATE AS START_DATE,
    :END_DATE AS END_DATE
);

RETURN 'Data preparation completed successfully. Ready for analysis phase.';
END;
$$;

RTS_Weekly_Task_Part2_Analysis.sql code:
CREATE OR REPLACE PROCEDURE Return_to_stock_Analysis_Procedure()
RETURNS STRING
LANGUAGE SQL
AS
$$
DECLARE
FISCAL_WEEK_START INT;
FISCAL_WEEK_END INT;
START_DATE DATE;
END_DATE DATE;

BEGIN

-- Load fiscal parameters from data prep procedure
SELECT FISCAL_WEEK_START, FISCAL_WEEK_END, START_DATE, END_DATE 
INTO :FISCAL_WEEK_START, :FISCAL_WEEK_END, :START_DATE, :END_DATE 
FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FISCAL_PARAMS;

-- Load prepared base tables
CREATE OR REPLACE TEMPORARY TABLE BASE_RX AS (
SELECT * FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_BASE_RX
);

CREATE OR REPLACE TEMPORARY TABLE FINAL_VERIFICATION AS (
SELECT * FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FINAL_VERIFICATION
);

CREATE OR REPLACE TEMPORARY TABLE RETURN_TO_STOCK AS (
SELECT * FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_RETURN_TO_STOCK
);

---------------BREAKING DOWN AT THE PRESCRIPTION LEVEL-----------------------------------------------------
----------------------------------------------------------------------------------------------------------
----only taking the first instance that return to stock occurred. This will not take into consideration if the Rx was returned to stock multiple times.

CREATE OR REPLACE TEMPORARY TABLE BASE_RX_STEP1 AS ( 
SELECT 
  BASE.RX_NBR 
, BASE.STORE_NBR 
, BASE.FILL_NBR 
, MIN(QV2_DATE) AS MIN_QV2_DATE
FROM BASE_RX AS BASE 
JOIN FINAL_VERIFICATION AS VERF 
ON BASE.RX_NBR = VERF.RX_NBR 
AND BASE.FILL_NBR = VERF.FILL_NBR 
AND BASE.STORE_NBR = VERF.STORE_NBR
GROUP BY 1,2,3
);

CREATE OR REPLACE TEMPORARY TABLE BASE_RX_STEP2 AS ( 
SELECT 
   BASE.RX_NBR 
 , BASE.STORE_NBR 
 , BASE.FILL_NBR
 , MIN(RTS_DATE) AS MIN_RTS_DATE
FROM BASE_RX AS BASE 
LEFT JOIN RETURN_TO_STOCK AS INV 
ON INV.STORE_NBR = BASE.STORE_NBR 
AND INV.DELETED_FILL_NBR = BASE.FILL_NBR 
AND INV.DELETED_RX_NBR = BASE.RX_NBR
GROUP BY 1,2,3
);

CREATE OR REPLACE TEMPORARY TABLE BASE_RX_STEP3 AS ( 
SELECT 
   STEP1.RX_NBR 
 , STEP1.STORE_NBR 
 , STEP1.FILL_NBR
 , STEP1.MIN_QV2_DATE 
 , STEP2.MIN_RTS_DATE
 , CASE 
    WHEN STEP1.MIN_QV2_DATE IS NOT NULL 
    THEN 1 
    ELSE 0 
    END AS QV2_IND
 , CASE 
    WHEN STEP2.MIN_RTS_DATE IS NOT NULL 
    THEN 1 
    ELSE 0 
    END AS RTS_INVENTORY_IND 
FROM BASE_RX_STEP1 AS STEP1 
LEFT JOIN BASE_RX_STEP2 AS STEP2 
ON STEP1.RX_NBR = STEP2.RX_NBR 
AND STEP1.STORE_NBR = STEP2.STORE_NBR 
AND STEP1.FILL_NBR = STEP2.FILL_NBR
);

CREATE OR REPLACE TEMPORARY TABLE BASE_RX_STEP4 AS ( 
SELECT 
     BASE. * 
   , PF.NDC
   , PF.SOURCE_CD
   , PF.RXC_PATIENT_ID
   , PF.PRESCRIPTION_FILL_TS
   , PF.POS_TXN_TS
   , DRG.GCN
   , STR.RX_AREA_NBR
   , STR.RX_DISTRICT_NBR
   , STR.RX_REGION_NBR
FROM BASE_RX_STEP3 AS BASE
JOIN (SELECT 
        RX_NBR 
      , STORE_NBR 
      , FILL_NBR 
      , SOURCE_CD 
      , NDC 
      , RXC_PATIENT_ID 
      , POS_TXN_TS
      , PRESCRIPTION_FILL_TS
  FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PF 
  WHERE PRESCRIPTION_FILL_TS > DATEADD(MONTH, -12, :START_DATE)
  ) AS PF
ON BASE.RX_NBR = PF.RX_NBR 
AND BASE.STORE_NBR = PF.STORE_NBR 
AND BASE.FILL_NBR = PF.FILL_NBR
JOIN CORE_RX.CURATED_LOCATION.STORE AS STR 
ON PF.STORE_NBR = STR.STORE_NBR
LEFT JOIN CORE_RX.CURATED_PRODUCT.DRUG AS DRG 
ON PF.NDC = DRG.NDC
);
    
-- ------------------------------
--     -------GRABBING THE FILL SOURCE / SCHEDULED REASON FOR THE SCRIPTS-------------------------------------------------------------------
CREATE OR REPLACE TEMPORARY TABLE RF_FILL_SCRIPTS_STEP1 AS ( 
SELECT
      PF.RX_NBR 
    , PF.STORE_NBR 
    , PF.FILL_NBR 
    , PF.PRESCRIPTION_FILL_TS 
    , PF.SOURCE_CD 
    , PF.LAST_UPDATED_TS
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PF
JOIN BASE_RX_STEP4 AS BASE
    ON PF.RX_NBR = BASE.RX_NBR 
    AND PF.STORE_NBR = BASE.STORE_NBR 
    AND PF.FILL_NBR = BASE.FILL_NBR
);

CREATE OR REPLACE TEMPORARY TABLE RF_FILL_SCRIPTS_STEP2 AS (
SELECT 
     PF.RX_NBR 
   , PF.STORE_NBR 
   , PF.FILL_NBR 
   , PF.PRESCRIPTION_FILL_TS 
   , PF.SOURCE_CD 
   , PF.LAST_UPDATED_TS
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_HISTORY AS PF 
JOIN BASE_RX_STEP4 AS BASE 
    ON PF.RX_NBR = BASE.RX_NBR 
    AND PF.STORE_NBR = BASE.STORE_NBR 
    AND PF.FILL_NBR = BASE.FILL_NBR
);

-- --only looking at the first instance of the script.
CREATE OR REPLACE TEMPORARY TABLE RF_FILL_SCRIPTS_STEP3 AS ( 
SELECT *
FROM (
   SELECT *
   FROM RF_FILL_SCRIPTS_STEP1 
   UNION
   SELECT *
   FROM RF_FILL_SCRIPTS_STEP2)
QUALIFY 
    ROW_NUMBER()OVER(PARTITION BY RX_NBR, STORE_NBR, FILL_NBR ORDER BY LAST_UPDATED_TS ASC) = 1
);
        
CREATE OR REPLACE TEMPORARY TABLE RF_FILL_SCRIPTS_STEP4 AS (
SELECT DISTINCT 
         STORE_NBR
       , RX_NBR
       , FILL_NBR
       , PRESCRIPTION_FILL_TS
FROM (
SELECT DISTINCT 
          STORE_NBR
        , RX_NBR
        , FILL_NBR
        , PRESCRIPTION_FILL_TS
        , SOURCE_CD
FROM RF_FILL_SCRIPTS_STEP3
WHERE
    SOURCE_CD IN (6,25)   
UNION        
SELECT DISTINCT 
          a.STORE_NBR 
        , a.RX_NBR 
        , a.FILL_NBR 
        , a.PRESCRIPTION_FILL_TS 
        , a.SOURCE_CD
FROM RF_FILL_SCRIPTS_STEP3 a
INNER JOIN CORE_RX.CURATED_SCRIPT.READYFILL_RXC_SCRIPT rf    
     ON a.STORE_NBR = rf.STORE_NBR
     AND a.RX_NBR = rf.RX_NBR
     AND rf.READYFILL_ENROLL_STATUS_CD = 'E'
     AND a.PRESCRIPTION_FILL_TS BETWEEN TO_DATE(rf.EFFECTIVE_START_TS) AND TO_DATE(rf.EFFECTIVE_END_TS)
WHERE 
    SOURCE_CD IN (1,4,24)) a
);
        
CREATE OR REPLACE TEMPORARY TABLE FORMER_FILLS AS ( 
SELECT DISTINCT
      PF.RX_NBR 
    , PF.STORE_NBR 
    , PF.FILL_NBR 
    , PF.PRESCRIPTION_FILL_TS 
    , DRG.GCN
    , PF.SCHEDULE_FILL_REASON_ID
    , PF.RXC_PATIENT_ID
    , PF.SOURCE_CD
    , PF.POS_TXN_TS
FROM 
(SELECT 
      RX_NBR 
    , STORE_NBR 
    , FILL_NBR 
    , PRESCRIPTION_FILL_TS 
    , SCHEDULE_FILL_REASON_ID
    , RXC_PATIENT_ID
    , POS_TXN_TS
    , NDC
    , SOURCE_CD
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL
WHERE PRESCRIPTION_FILL_TS > DATEADD(MONTH, -12, :START_DATE)
) AS PF
JOIN CORE_RX.CURATED_PRODUCT.DRUG AS DRG
    ON PF.NDC = DRG.NDC
JOIN BASE_RX_STEP4 AS BASE
    ON BASE.RXC_PATIENT_ID = PF.RXC_PATIENT_ID 
    AND BASE.GCN = DRG.GCN
);

CREATE OR REPLACE TEMPORARY TABLE PRV_RX AS ( 
SELECT DISTINCT
        RX_NBR 
      , STORE_NBR 
      , FILL_NBR
      , LAG(SCHEDULE_FILL_REASON_ID) OVER(PARTITION BY RXC_PATIENT_ID, GCN ORDER BY PRESCRIPTION_FILL_TS DESC) AS PREV_SCHEDULE_RSN
      , LAG(POS_TXN_TS) OVER(PARTITION BY RXC_PATIENT_ID, GCN ORDER BY PRESCRIPTION_FILL_TS DESC) AS PREV_POS_TXN_TS
FROM FORMER_FILLS
);
    
CREATE OR REPLACE TEMPORARY TABLE BASE_RX_STEP5 AS ( 
SELECT DISTINCT
        BASE. *
      , PRV.PREV_SCHEDULE_RSN
      , PRV.PREV_POS_TXN_TS
      , DATEDIFF(MONTH,PREV_POS_TXN_TS, BASE.POS_TXN_TS) AS MONTHS_BETWEEN_LAST_FILL 
      , CASE 
            WHEN MONTHS_BETWEEN_LAST_FILL BETWEEN 0 AND 12 THEN 'FILL HISTORY IN LAST YEAR'
            ELSE 'NO FILL HISTORY IN LAST YEAR'
        END AS FILL_HISTORY_IND
      , CASE 
            WHEN BASE.FILL_NBR = 0 THEN 'FILL 00'
            ELSE 'FILL 01+'
         END AS FILL_NUMBER
     , CASE 
             --WHEN PRV.PREV_SCHEDULE_RSN IN ('3','9','15') THEN 'RF'
             --WHEN PRV.PREV_SCHEDULE_RSN IS NOT NULL AND PRV.PREV_SCHEDULE_RSN NOT IN ('3','9','15') THEN 'SCHEDULED - NON RF'
             WHEN RF.RX_NBR IS NOT NULL THEN 'RF'
             WHEN PRV.PREV_SCHEDULE_RSN IS NULL AND DIM.RX_FILL_SOURCE_DSC IN ('PPI (eRx)') THEN 'eRx'
             WHEN PRV.PREV_SCHEDULE_RSN IS NULL AND DIM.RX_FILL_SOURCE_DSC IN ('Manual Data Entry') THEN 'Manual Data Entry'
             WHEN PRV.PREV_SCHEDULE_RSN IS NULL AND DIM.RX_FILL_SOURCE_DSC IN ('IVR','DIGITAL') THEN 'IVR/Digital'
             ELSE 'Other'
       END AS FILL_SOURCE 
     , DATEDIFF(DAY, MIN_RTS_DATE, BASE.POS_TXN_TS) AS DAYS_BETWEEN_RTS_AND_SOLD
FROM BASE_RX_STEP4 AS BASE 
JOIN PRV_RX AS PRV
    ON BASE.RX_NBR = PRV.RX_NBR 
    AND BASE.FILL_NBR = PRV.FILL_NBR 
    AND BASE.STORE_NBR = PRV.STORE_NBR
LEFT JOIN CORE_RX.CURATED_SCRIPT.DIM_RX_FILL_SOURCE AS DIM 
    ON DIM.RX_FILL_SOURCE_CD = BASE.SOURCE_CD

LEFT JOIN RF_FILL_SCRIPTS_STEP4 AS RF 
    ON BASE.RX_NBR = RF.RX_NBR 
    AND BASE.STORE_NBR = RF.STORE_NBR 
    AND BASE.FILL_NBR = RF.FILL_NBR
);
---------------------------------------------------------------------------------------------------------
---------TYING THE ACTIVITIES TO THE FISCAL WEEKS, DEN/NUM FIS WEEKS WILL BE TIED TO DIFFERENT DATES-----
CREATE OR REPLACE TEMPORARY TABLE BASE_RX_QV2_FISCAL_WEEK_AGG AS (
SELECT 
      FISCAL_WEEK_NBR
    , FISCAL_MONTH_NBR
    , RX_AREA_NBR 
    , RX_REGION_NBR 
    , RX_DISTRICT_NBR
    , FILL_NUMBER
    , FILL_HISTORY_IND
    , FILL_SOURCE
    , COUNT(
            CASE WHEN QV2_IND = 1 THEN RX_NBR
            ELSE NULL END) AS TTL_VERIFIED
    , COUNT( 
            CASE WHEN RTS_INVENTORY_IND = 1 
            AND DAYS_BETWEEN_RTS_AND_SOLD BETWEEN 0 AND 5 THEN RX_NBR
            ELSE NULL END) AS TTL_RTS_AND_SOLD_WITHIN_FIVE_DAYS 
    , COUNT( 
            CASE WHEN RTS_INVENTORY_IND = 1
            AND DAYS_BETWEEN_RTS_AND_SOLD BETWEEN 0 AND 30 THEN RX_NBR 
            ELSE NULL END) AS TTL_RTS_AND_SOLD_WITHIN_THIRTY_DAYS 
    , COUNT( 
            CASE WHEN RTS_INVENTORY_IND = 1
            AND DAYS_BETWEEN_RTS_AND_SOLD IS NOT NULL THEN RX_NBR 
            ELSE NULL END) AS TTL_RTS_AND_SOLD_NO_TIME_LIMIT
FROM BASE_RX_STEP5 AS BASE 

JOIN (SELECT 
          FISCAL_WEEK_NBR
        , FISCAL_MONTH_NBR 
        , START_DT 
        , END_DT
      FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
      WHERE FISCAL_WEEK_NBR BETWEEN :FISCAL_WEEK_START AND :FISCAL_WEEK_END) AS FIS 
    ON TO_DATE(BASE.MIN_QV2_DATE) BETWEEN FIS.START_DT AND FIS.END_DT
GROUP BY 1,2,3,4,5,6,7,8
);
    
CREATE OR REPLACE TEMPORARY TABLE BASE_RX_RTS_FISCAL_WEEK_AGG AS (
SELECT 
      FISCAL_WEEK_NBR
    , FISCAL_MONTH_NBR
    , RX_AREA_NBR 
    , RX_REGION_NBR 
    , RX_DISTRICT_NBR
    , FILL_NUMBER
    , FILL_HISTORY_IND
    , FILL_SOURCE
    , COUNT(
            CASE WHEN RTS_INVENTORY_IND = 1 THEN RX_NBR
            ELSE NULL END) AS TTL_RTS
FROM BASE_RX_STEP5 AS BASE 
JOIN (SELECT 
         FISCAL_WEEK_NBR
        , FISCAL_MONTH_NBR 
        , START_DT 
        , END_DT
      FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
      WHERE FISCAL_WEEK_NBR BETWEEN :FISCAL_WEEK_START AND :FISCAL_WEEK_END) AS FIS 
    ON TO_DATE(BASE.MIN_RTS_DATE) BETWEEN FIS.START_DT AND FIS.END_DT
GROUP BY 1,2,3,4,5,6,7,8
); 
    
-- --BROKEN DOWN AT THE FISCAL WEEK/STORE LEVEL AND IS AT THE PRESCRIPTION LEVEL 
-- --DOES NOT TAKE INTO ACCOUNT IF A PRESCRIPTION IS RETURNED TO STOCK MULTIPLE TIMES OR NOT
CREATE OR REPLACE TEMPORARY TABLE RX_LEVEL_FINAL_TABLE AS (
SELECT 
      QV2.FISCAL_WEEK_NBR
    , QV2.FISCAL_MONTH_NBR
    , QV2.RX_AREA_NBR 
    , QV2.RX_REGION_NBR 
    , QV2.RX_DISTRICT_NBR
    , QV2.FILL_NUMBER
    , QV2.FILL_HISTORY_IND
    , QV2.FILL_SOURCE
    , QV2.TTL_VERIFIED 
    , RTS.TTL_RTS
    , CAST(RTS.TTL_RTS AS DECIMAL(14,4)) / CAST(QV2.TTL_VERIFIED AS DECIMAL(14,4)) AS RTS_RATE
    , QV2.TTL_RTS_AND_SOLD_WITHIN_FIVE_DAYS  
    , QV2.TTL_RTS_AND_SOLD_WITHIN_THIRTY_DAYS  
    , QV2.TTL_RTS_AND_SOLD_NO_TIME_LIMIT
FROM BASE_RX_QV2_FISCAL_WEEK_AGG AS QV2
LEFT JOIN BASE_RX_RTS_FISCAL_WEEK_AGG AS RTS
    ON QV2.FISCAL_WEEK_NBR = RTS.FISCAL_WEEK_NBR
    AND QV2.FISCAL_MONTH_NBR = RTS.FISCAL_MONTH_NBR
    AND QV2.RX_AREA_NBR = RTS.RX_AREA_NBR 
    AND QV2.RX_REGION_NBR = RTS.RX_REGION_NBR
    AND QV2.RX_DISTRICT_NBR = RTS.RX_DISTRICT_NBR
    AND QV2.FILL_NUMBER = RTS.FILL_NUMBER 
    AND QV2.FILL_HISTORY_IND = RTS.FILL_HISTORY_IND
    AND QV2.FILL_SOURCE = RTS.FILL_SOURCE
);

-- ----------------------------------------------VOLUME LEVEL METRIC------------------------------------
-- ------------IDENTIFIES THE INSTANCES THAT A SCRIPT IS RETURNED TO STOCK/FINAL VERIFIED---------------   
-- -----------------------------------------------------------------------------------------------------   
CREATE OR REPLACE TEMPORARY TABLE FISCAL_WEEK_AGG_RTS_VOLUME AS (    
SELECT 
      FISCAL_WEEK_NBR
    , FISCAL_MONTH_NBR
    , RX_AREA_NBR 
    , RX_REGION_NBR 
    , RX_DISTRICT_NBR
    , FILL_NUMBER
    , FILL_HISTORY_IND
    , FILL_SOURCE
    , COUNT(RTS.DELETED_RX_NBR) AS TTL_RTS
FROM RETURN_TO_STOCK AS RTS 
JOIN BASE_RX_STEP5 AS BASE 
    ON RTS.DELETED_RX_NBR = BASE.RX_NBR 
    AND RTS.STORE_NBR = BASE.STORE_NBR 
    AND RTS.DELETED_FILL_NBR = BASE.FILL_NBR
JOIN (SELECT 
         FISCAL_WEEK_NBR
        , FISCAL_MONTH_NBR 
        , START_DT 
        , END_DT
      FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
      WHERE FISCAL_WEEK_NBR BETWEEN :FISCAL_WEEK_START AND :FISCAL_WEEK_END) AS FIS 
    ON TO_DATE(RTS.RTS_DATE) BETWEEN FIS.START_DT AND FIS.END_DT
GROUP BY 1,2,3,4,5,6,7,8
); 

CREATE OR REPLACE TEMPORARY TABLE FISCAL_WEEK_AGG_QV2_VOLUME AS (    
SELECT 
      FISCAL_WEEK_NBR
    , FISCAL_MONTH_NBR
    , RX_AREA_NBR 
    , RX_REGION_NBR 
    , RX_DISTRICT_NBR
    , FILL_NUMBER
    , FILL_HISTORY_IND
    , FILL_SOURCE
    , COUNT(QV2.RX_NBR) AS TTL_QV2
FROM FINAL_VERIFICATION AS QV2

JOIN BASE_RX_STEP5 AS BASE 
    ON QV2.RX_NBR = BASE.RX_NBR 
    AND QV2.STORE_NBR = BASE.STORE_NBR 
    AND QV2.FILL_NBR = BASE.FILL_NBR

JOIN (SELECT 
         FISCAL_WEEK_NBR
        , FISCAL_MONTH_NBR 
        , START_DT 
        , END_DT
      FROM CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK
      WHERE FISCAL_WEEK_NBR BETWEEN :FISCAL_WEEK_START AND :FISCAL_WEEK_END) AS FIS 
    ON TO_DATE(QV2.QV2_DATE) BETWEEN FIS.START_DT AND FIS.END_DT 
GROUP BY 1,2,3,4,5,6,7,8
); 

--     --THIS HAS THE RETURN TO STOCK RATE BROKEN DOWN AT THE FISCAL WEEK / STORE NUMBER AND IS THE VOLUME. 
--     --THIS TAKES INTO CONSIDERATION THE NUMBER OF TIMES THAT A SCRIPT IS RTS/FINAL VERIFIED. 
CREATE OR REPLACE TEMPORARY TABLE VOLUME_LEVEL_FINAL_TABLE AS ( 
SELECT 
      QV2.FISCAL_WEEK_NBR
    , QV2.FISCAL_MONTH_NBR
    , QV2.RX_AREA_NBR 
    , QV2.RX_REGION_NBR 
    , QV2.RX_DISTRICT_NBR
    , QV2.FILL_NUMBER
    , QV2.FILL_HISTORY_IND
    , QV2.FILL_SOURCE
    , RTS.TTL_RTS AS TTL_RTS_VOLUME
    , QV2.TTL_QV2 AS TTL_QV2_VOLUME
    , CAST(TTL_RTS_VOLUME AS DECIMAL(14,4)) / CAST(TTL_QV2_VOLUME AS DECIMAL(14,4)) AS RTS_VOLUME_RATE
FROM FISCAL_WEEK_AGG_QV2_VOLUME AS QV2
LEFT JOIN FISCAL_WEEK_AGG_RTS_VOLUME AS RTS
    ON QV2.FISCAL_WEEK_NBR = RTS.FISCAL_WEEK_NBR
    AND QV2.FISCAL_MONTH_NBR = RTS.FISCAL_MONTH_NBR
    AND QV2.RX_AREA_NBR = RTS.RX_AREA_NBR 
    AND QV2.RX_REGION_NBR = RTS.RX_REGION_NBR
    AND QV2.RX_DISTRICT_NBR = RTS.RX_DISTRICT_NBR
    AND QV2.FILL_NUMBER = RTS.FILL_NUMBER 
    AND QV2.FILL_HISTORY_IND = RTS.FILL_HISTORY_IND
    AND QV2.FILL_SOURCE = RTS.FILL_SOURCE 
);

CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD AS ( 
SELECT RX. *,
       VL.TTL_RTS_VOLUME, 
       VL.TTL_QV2_VOLUME
FROM RX_LEVEL_FINAL_TABLE AS RX 
LEFT JOIN VOLUME_LEVEL_FINAL_TABLE AS VL 
     ON RX.FISCAL_WEEK_NBR = VL.FISCAL_WEEK_NBR
     AND RX.FISCAL_MONTH_NBR = VL.FISCAL_MONTH_NBR
     AND RX.RX_AREA_NBR = VL.RX_AREA_NBR 
     AND RX.RX_REGION_NBR = VL.RX_REGION_NBR
     AND RX.RX_DISTRICT_NBR = VL.RX_DISTRICT_NBR
     AND RX.FILL_NUMBER = VL.FILL_NUMBER 
     AND RX.FILL_HISTORY_IND = VL.FILL_HISTORY_IND
     AND RX.FILL_SOURCE = VL.FILL_SOURCE 
    );

CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD_2 AS (
SELECT 
    DL. *, 
    FIS.START_DT, 
    FIS.END_DT, 
    FIS.FISCAL_WEEK_DSC
FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD AS DL 
LEFT JOIN CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK AS FIS 
    ON DL.FISCAL_WEEK_NBR = FIS.FISCAL_WEEK_NBR);

    
CREATE OR REPLACE TABLE DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD AS ( 
SELECT *
FROM DL_RX_OPERATION.RX_OPS_SANDBOX.RETURN_TO_STOCK_NEW_DASHBOARD_2 
);

-- Clean up temporary tables created by data prep procedure
DROP TABLE IF EXISTS DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_BASE_RX;
DROP TABLE IF EXISTS DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FINAL_VERIFICATION;
DROP TABLE IF EXISTS DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_RETURN_TO_STOCK;
DROP TABLE IF EXISTS DL_RX_OPERATION.RX_OPS_SANDBOX.RTS_TEMP_FISCAL_PARAMS;

RETURN 'Analysis and dashboard creation completed successfully';
END;
$$;
