-- Code reflects changes for H1

----- QUERY START ------
    SET START_DATE = DATE'2024-08-31'; --DATE'2024-06-30';
    SET END_DATE =  DATE'2025-08-30'; --DATE'2024-09-28';


--- START OF STEP 1 -- PULLING PROMISE TIME RELATED METRICS -- EXPECTED PRM TIME, ACT PROMISE TIME, NEXT DA PRT SCRIPTS

CREATE OR REPLACE TEMPORARY TABLE BASE_SCRIPTS AS ( 
    SELECT 
          PFILL.RX_NBR 
        , PFILL.STORE_NBR 
        , PFILL.FILL_NBR 
        , PFILL.RXC_PATIENT_ID 
        , PFILL.NDC 
        , PFILL.WRITTEN_TS
        , PFILL.DAY_SUPPLY_QTY
        , PFILL.PRESCRIPTION_FILL_TS
        , PFILL.RXC_PRESCRIPTION_FILL_ID -- TEST THE RECORD COUNT WITH THIS
        , PFILL.FILL_STATUS_CD
        , PFILL.RXC_PRESCRIBER_ID
        , PFILL.PRESCRIBER_STORE_DISTANCE_NBR
        , PFILL.PATIENT_PRESCRIBER_DISTANCE_NBR
        , PFILL.PATIENT_STORE_DISTANCE_NBR
        , PFILL.POS_TXN_TS

        , DRG.GCN_SEQUENCE_NBR
        , DRG.DEA_CD
        , DRG.LABEL_NM
        , PFILL.ACUTE_IND -- USE THIS FOR ACTUE VS MAINT
        , DRG.THERAPEUTIC_CLASS_CD

        , PTNT.BIRTH_DT
        , PTNT.GENDER_CD

    FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PFILL 

    LEFT JOIN CORE_RX.CURATED_PATIENT.PATIENT AS PTNT 
        ON PFILL.RXC_PATIENT_ID = PTNT.RXC_PATIENT_ID
    LEFT JOIN CORE_RX.CURATED_PRODUCT.DRUG AS DRG
        ON PFILL.NDC = DRG.NDC 

    WHERE PRESCRIPTION_FILL_TS BETWEEN $START_DATE AND $END_DATE
        AND PFILL.FILL_NBR = 0
        AND RX_ORIGIN_CD IN ('3')
); 


SELECT COUNT(*) FROM BASE_SCRIPTS; --   744107515

CREATE OR REPLACE TEMPORARY TABLE INDUCTION_TIME AS ( 
SELECT 
      X.RX_NBR 
    , X.FILL_NBR 
    , X.STORE_NBR 
    , MIN(PACT.REC_EFF_TS) AS INDUCTION_TS
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_ACTIVITY AS PACT 
INNER JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_XREF AS X
    ON PACT.RXC_PRESCRIPTION_FILL_ID = X.RXC_PRESCRIPTION_FILL_ID
INNER JOIN BASE_SCRIPTS AS BASE 
    ON X.RX_NBR = BASE.RX_NBR 
    AND X.FILL_NBR = BASE.FILL_NBR 
    AND X.STORE_NBR = BASE.STORE_NBR
WHERE PACT.EFFECTIVE_TS BETWEEN $START_DATE-180 AND $END_DATE
GROUP BY 1,2,3
);


--GATHERING THE ORIGINAL PROMISE TIME SET FOR THESE SCRITPS.
CREATE OR REPLACE TEMPORARY TABLE ORIGINAL_PROMISE_TIME AS ( 
SELECT 
        BASE.RX_NBR 
      , BASE.STORE_NBR 
      , BASE.FILL_NBR 
      , MIN(RT.PROMISE_TS) AS PROMISE_TS
FROM APP_RXOPS.CURATED_RXOPS.RXOPS_RXC_PRESCRIPTION_FILL_RT_HIST AS RT 
INNER JOIN BASE_SCRIPTS AS BASE 
    ON RT.RX_NBR = BASE.RX_NBR 
    AND RT.STORE_NBR = BASE.STORE_NBR 
    AND RT.FILL_NBR = BASE.FILL_NBR
GROUP BY 1,2,3
); 

CREATE OR REPLACE TEMPORARY TABLE BASE_SCRIPTS_V2 AS ( 
    SELECT 
        BASE.*,
        IND.INDUCTION_TS, 
        PRT.PROMISE_TS AS ORIGINAL_PROMISE_TIME,
        DATEDIFF(YEAR, BIRTH_DT, CAST(INDUCTION_TS AS DATE)) AS PTNT_AGE,
        CASE WHEN PTNT_AGE BETWEEN 0 AND 1 THEN 'INFANT'
               WHEN PTNT_AGE BETWEEN 2 AND 12 THEN 'PEDIATRIC'
               WHEN PTNT_AGE BETWEEN 13 AND 17 THEN 'TEEN'
               WHEN PTNT_AGE BETWEEN 18 AND 64 THEN 'ADULT'
               WHEN PTNT_AGE >= 65 THEN 'ELDERLY'
        ELSE 'UNKNOWN'
        END AS AGE_GROUP,    
        CASE WHEN DAY_SUPPLY_QTY <= 3 THEN 1 
        ELSE 0 
        END AS DAY_SUPPLY_QTY_THREE_OR_LESS_IND
    FROM BASE_SCRIPTS AS BASE 
    LEFT JOIN INDUCTION_TIME AS IND 
        ON BASE.RX_NBR = IND.RX_NBR 
        AND BASE.FILL_NBR = IND.FILL_NBR 
        AND BASE.STORE_NBR = IND.STORE_NBR
    LEFT JOIN ORIGINAL_PROMISE_TIME AS PRT
        ON BASE.RX_NBR = PRT.RX_NBR 
        AND BASE.FILL_NBR = PRT.FILL_NBR 
        AND BASE.STORE_NBR = PRT.STORE_NBR
);



CREATE OR REPLACE TEMPORARY TABLE BASE_SCRIPTS_V3 AS ( 
    SELECT DISTINCT
          BS.*
        , ONR.TRANSACTION_START_TS AS PATIENT_ARRIVAL_TIME
        , ONR.FIRST_ATTEMPT_ORDER_READY
        , ONR.FILL_LOCATION_CD
        , ONR.FILL_DISPOSITION_CD
        , ONR.ONR_BFR_PRMS
        , ONR.POS_EVENT_ID
        , ONR.TRANSACTION_END_TS
        , CASE WHEN ONR.RX_NBR <> ONR.NEW_RX_NBR THEN 1 ELSE 0 END AS NEW_RX_IND
        , CASE WHEN AN.RXC_ACTION_NOTE_ID IS NOT NULL THEN 1 
          ELSE 0 END AS ACTION_NOTE_IND
        , AN.ACTION_NOTES_TYPE_CD
        , AN.PATIENT_CONTACT_REASON_TXT
    FROM dl_rx_operation.rx_ops_sandbox.PROMISE_TIME_DATA_LAYER_BASE_SCRIPTS_V2_C590078 AS BS 
    LEFT JOIN APP_OMNIRX.OMNI_DL.ONR_FINAL_TBL AS ONR 
        ON  BS.RX_NBR = ONR.NEW_RX_NBR 
        AND BS.STORE_NBR = ONR.STORE_NBR 
        AND BS.FILL_NBR = ONR.NEW_FILL_NBR
    LEFT JOIN CORE_RX.CURATED_SCRIPT.RXC_ACTION_NOTE AS AN 
        ON  AN.RX_NBR = BS.RX_NBR
        AND AN.STORE_NBR = BS.STORE_NBR
        AND AN.FILL_NBR = BS.FILL_NBR
    QUALIFY ROW_NUMBER() OVER (PARTITION BY BS.STORE_NBR, BS.RX_NBR, BS.FILL_NBR ORDER BY AN.REC_EFF_TS ASC)=1
);




CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_HISTORY_V2_2 AS (
    SELECT BASE.*
        ,CASE WHEN DTLS.RXC_PRESCRIPTION_FILL_ID IS NULL THEN 1 ELSE 0 END AS DTLS_NULL_IND 
        ,COALESCE(DTLS.PRIOR_SOLD_IND, 'N') AS HISTORY_IND
        ,DTLS.DRUG_URGENCY_TRIAGE_INDUCTION_CD
        ,DTLS.BUNDLED_PRESCRIPTION_IND
        ,DTLS.ORIGINAL_GENERATED_PROMISE_TS 
        ,DATEDIFF(DAY, CAST(BASE.WRITTEN_TS AS DATE) , CAST(BASE.PRESCRIPTION_FILL_TS AS DATE)) AS WRITTEN_TO_FILL
    FROM BASE_SCRIPTS_V3 AS BASE
    INNER JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_XREF AS X
        ON BASE.STORE_NBR = X.STORE_NBR
           AND BASE.RX_NBR = X.RX_NBR
    LEFT JOIN  CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_ADDITIONAL_DETAILS AS DTLS
        ON     X.RXC_PRESCRIPTION_FILL_ID = DTLS.RXC_PRESCRIPTION_FILL_ID
    WHERE ACTION_NOTE_IND = 0   --APPLYING FILTERS TO REDUCE THE SIZE
          AND NEW_RX_IND = 0
    QUALIFY ROW_NUMBER() OVER (PARTITION BY BASE.STORE_NBR, BASE.RX_NBR, BASE.FILL_NBR ORDER BY DTLS.REC_EFF_TS ASC)=1
);


--- ADDING STORE HOURS OF OPERATION


CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_HISTORY_V2_3 AS (
SELECT V2.*,
       CASE 
            WHEN Upper(TIMEZONE_DSC) LIKE '%ATLANTIC%' THEN INDUCTION_TS
            WHEN Upper(TIMEZONE_DSC) LIKE '%EASTERN%' THEN INDUCTION_TS
            WHEN Upper(TIMEZONE_DSC) LIKE '%CENTRAL%' THEN DATEADD('HOUR',-1, INDUCTION_TS)
            WHEN Upper(TIMEZONE_DSC) LIKE '%MOUNTAIN%' THEN DATEADD('HOUR',-2, INDUCTION_TS)
            WHEN Upper(TIMEZONE_DSC) LIKE '%AZ%' THEN DATEADD('HOUR',-3, INDUCTION_TS)
            WHEN Upper(TIMEZONE_DSC) LIKE '%PACIFIC%' THEN DATEADD('HOUR',-3, INDUCTION_TS)
            WHEN Upper(TIMEZONE_DSC) LIKE '%ALASKA%' THEN DATEADD('HOUR',-5, INDUCTION_TS)
            WHEN Upper(TIMEZONE_DSC) LIKE '%HAWAII%' THEN DATEADD('HOUR',-6, INDUCTION_TS)
        END AS INDUCTION_TS_LOCAL,
        CASE 
            WHEN Upper(TIMEZONE_DSC) LIKE '%ATLANTIC%' THEN PATIENT_ARRIVAL_TIME
            WHEN Upper(TIMEZONE_DSC) LIKE '%EASTERN%' THEN PATIENT_ARRIVAL_TIME
            WHEN Upper(TIMEZONE_DSC) LIKE '%CENTRAL%' THEN DATEADD('HOUR',-1, PATIENT_ARRIVAL_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%MOUNTAIN%' THEN DATEADD('HOUR',-2, PATIENT_ARRIVAL_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%AZ%' THEN DATEADD('HOUR',-3, PATIENT_ARRIVAL_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%PACIFIC%' THEN DATEADD('HOUR',-3, PATIENT_ARRIVAL_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%ALASKA%' THEN DATEADD('HOUR',-5, PATIENT_ARRIVAL_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%HAWAII%' THEN DATEADD('HOUR',-6, PATIENT_ARRIVAL_TIME)
        END AS PATIENT_ARRIVAL_TIME_LOCAL,
        CASE 
            WHEN Upper(TIMEZONE_DSC) LIKE '%ATLANTIC%' THEN ORIGINAL_PROMISE_TIME
            WHEN Upper(TIMEZONE_DSC) LIKE '%EASTERN%' THEN ORIGINAL_PROMISE_TIME
            WHEN Upper(TIMEZONE_DSC) LIKE '%CENTRAL%' THEN DATEADD('HOUR',-1, ORIGINAL_PROMISE_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%MOUNTAIN%' THEN DATEADD('HOUR',-2, ORIGINAL_PROMISE_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%AZ%' THEN DATEADD('HOUR',-3, ORIGINAL_PROMISE_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%PACIFIC%' THEN DATEADD('HOUR',-3, ORIGINAL_PROMISE_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%ALASKA%' THEN DATEADD('HOUR',-5, ORIGINAL_PROMISE_TIME)
            WHEN Upper(TIMEZONE_DSC) LIKE '%HAWAII%' THEN DATEADD('HOUR',-6, ORIGINAL_PROMISE_TIME)
        END AS ORIGINAL_PROMISE_TIME_LOCAL,
        
        CASE WHEN DAYNAME(INDUCTION_TS_LOCAL) IN ('Sat', 'Sun') THEN 'WEEKEND' ELSE 'WEEKDAY' END AS IND_DAY,
        CASE WHEN DAYNAME(PATIENT_ARRIVAL_TIME_LOCAL) IN ('Sat', 'Sun') THEN 'WEEKEND' ELSE 'WEEKDAY' END AS PAT_ARR_DAY,
        CASE WHEN DAYNAME(ORIGINAL_PROMISE_TIME_LOCAL) IN ('Sat', 'Sun') THEN 'WEEKEND' ELSE 'WEEKDAY' END AS PRM_DAY,

        dayname(INDUCTION_TS) AS IND_DAY_OF_WEEK,
        
        CASE WHEN IND_DAY_OF_WEEK LIKE 'Sun' AND SUN_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SUN_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(INDUCTION_TS),' ',TIME(SUN_CLOSE_TIME_TXT))::TIMESTAMP           
         WHEN IND_DAY_OF_WEEK LIKE 'Mon' AND MON_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND MON_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.MON_CLOSE_TIME_TXT):: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Tue' AND TUE_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND TUE_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.TUE_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Wed' AND WED_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND WED_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.WED_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Thu' AND THU_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND THU_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.THU_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Fri' AND FRI_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND FRI_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.FRI_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Sat' AND SAT_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SAT_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.SAT_CLOSE_TIME_TXT) :: TIME)
        END AS STORE_CLOSE_TIME_LOCAL_IND,
        
        CASE WHEN IND_DAY_OF_WEEK LIKE 'Sun' AND SUN_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SUN_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(INDUCTION_TS),' ',TIME(SUN_OPEN_TIME_TXT))::TIMESTAMP           
         WHEN IND_DAY_OF_WEEK LIKE 'Mon' AND MON_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND MON_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.MON_OPEN_TIME_TXT):: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Tue' AND TUE_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND TUE_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.TUE_OPEN_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Wed' AND WED_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND WED_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.WED_OPEN_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Thu' AND THU_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND THU_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.THU_OPEN_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Fri' AND FRI_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND FRI_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.FRI_OPEN_TIME_TXT) :: TIME)
         WHEN IND_DAY_OF_WEEK LIKE 'Sat' AND SAT_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SAT_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(INDUCTION_TS):: DATE,time(STR.SAT_OPEN_TIME_TXT) :: TIME)
        END AS STORE_OPEN_TIME_LOCAL_IND,
        CASE WHEN INDUCTION_TS_LOCAL BETWEEN STORE_OPEN_TIME_LOCAL_IND AND STORE_CLOSE_TIME_LOCAL_IND THEN 1 ELSE 0 END AS IND_IN_HOO_IND,

        --- PAT ARRIVAL DURATION - BUSINESS HOURS
        CASE WHEN DATEDIFF(DAY, INDUCTION_TS_LOCAL, PATIENT_ARRIVAL_TIME_LOCAL) > 1 THEN DATEADD(DAY, 1, STORE_CLOSE_TIME_LOCAL_IND) ELSE PATIENT_ARRIVAL_TIME_LOCAL END AS CAP_PATIENT_ARRIVAL_TIME_LOCAL,
        DATEDIFF(DAY, INDUCTION_TS_LOCAL, CAP_PATIENT_ARRIVAL_TIME_LOCAL) AS IND_PAT_ARRVL_DIFF,
        CASE WHEN IND_PAT_ARRVL_DIFF > 0 THEN 1 ELSE 0 END AS NEXT_DAY_PICKUP_IND,
        
        dayname(CAP_PATIENT_ARRIVAL_TIME_LOCAL) AS PAT_ARRVL_DAY_OF_WEEK,
        
        CASE WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Sun' AND SUN_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SUN_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL),' ',TIME(SUN_CLOSE_TIME_TXT))::TIMESTAMP           
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Mon' AND MON_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND MON_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.MON_CLOSE_TIME_TXT):: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Tue' AND TUE_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND TUE_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.TUE_CLOSE_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Wed' AND WED_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND WED_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.WED_CLOSE_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Thu' AND THU_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND THU_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.THU_CLOSE_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Fri' AND FRI_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND FRI_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.FRI_CLOSE_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Sat' AND SAT_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SAT_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.SAT_CLOSE_TIME_TXT) :: TIME)
        END AS STORE_CLOSE_TIME_LOCAL_PAT,
        
        CASE WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Sun' AND SUN_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SUN_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL),' ',TIME(SUN_OPEN_TIME_TXT))::TIMESTAMP           
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Mon' AND MON_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND MON_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.MON_OPEN_TIME_TXT):: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Tue' AND TUE_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND TUE_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.TUE_OPEN_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Wed' AND WED_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND WED_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.WED_OPEN_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Thu' AND THU_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND THU_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.THU_OPEN_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Fri' AND FRI_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND FRI_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.FRI_OPEN_TIME_TXT) :: TIME)
         WHEN PAT_ARRVL_DAY_OF_WEEK LIKE 'Sat' AND SAT_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SAT_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL):: DATE,time(STR.SAT_OPEN_TIME_TXT) :: TIME)
        END AS STORE_OPEN_TIME_LOCAL_PAT,

         CASE WHEN (INDUCTION_TS_LOCAL < STORE_OPEN_TIME_LOCAL_IND) AND (CAP_PATIENT_ARRIVAL_TIME_LOCAL BETWEEN STORE_OPEN_TIME_LOCAL_IND AND STORE_CLOSE_TIME_LOCAL_IND) 
                  THEN DATEDIFF(MINUTE,INDUCTION_TS_LOCAL, STORE_OPEN_TIME_LOCAL_IND)
              WHEN (TO_DATE(INDUCTION_TS_LOCAL) < TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL)) AND (INDUCTION_TS_LOCAL > STORE_CLOSE_TIME_LOCAL_IND ) AND (CAP_PATIENT_ARRIVAL_TIME_LOCAL > STORE_OPEN_TIME_LOCAL_PAT) 
                  THEN DATEDIFF(MINUTE,INDUCTION_TS_LOCAL, STORE_OPEN_TIME_LOCAL_PAT)
              WHEN (TO_DATE(INDUCTION_TS_LOCAL) < TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL))
                  THEN DATEDIFF(MINUTE,STORE_CLOSE_TIME_LOCAL_IND, STORE_OPEN_TIME_LOCAL_PAT)  
        ELSE 0 END AS STORE_CLOSED_MINS,

        DATEDIFF(MINUTE,INDUCTION_TS_LOCAL, CAP_PATIENT_ARRIVAL_TIME_LOCAL) AS PAT_ARRVL_DUR,
        (PAT_ARRVL_DUR - STORE_CLOSED_MINS) AS ACT_PAT_ARRVL_DUR,
        
        CASE WHEN TO_DATE(INDUCTION_TS_LOCAL) = TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL) AND PAT_ARRVL_DUR BETWEEN 0 AND 240 THEN 'SAME DAY WITHIN 4 HOURS'
             WHEN TO_DATE(INDUCTION_TS_LOCAL) = TO_DATE(CAP_PATIENT_ARRIVAL_TIME_LOCAL) AND PAT_ARRVL_DUR > 240 THEN 'SAME DAY AFTER 4 HOURS'
             WHEN DATEDIFF(DAY,INDUCTION_TS_LOCAL, PATIENT_ARRIVAL_TIME_LOCAL) = 1 THEN 'NEXT DAY'
             WHEN DATEDIFF(DAY,INDUCTION_TS_LOCAL, PATIENT_ARRIVAL_TIME_LOCAL) > 1 THEN 'AFTER NEXT DAY'
             WHEN PATIENT_ARRIVAL_TIME_LOCAL IS NULL THEN 'AFTER NEXT DAY'
        ELSE 'EXCLUDE' END AS PAT_ARRVL_BUCKET,

        STR.ADDR1_TXT AS STORE_ADDR1_TXT,
        STR.ADDR2_TXT AS STORE_ADDR2_TXT,
        STR.CITY_NM AS STORE_CITY_NM,
        STR.STATE_CD AS STORE_STATE_CD,
        STR.ZIP_CD AS STORE_ZIP_CD,
        STR.FACILITY_TYP_DSC,
        STR.TIMEZONE_DSC
        
FROM   PROMISE_TIME_HISTORY_V2_2 AS V2
LEFT JOIN CORE_RX.CURATED_LOCATION.STORE AS STR
    ON  V2.STORE_NBR = STR.STORE_NBR
);




--- DIGITAL ENGAGEMENT METRICS
CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_HISTORY_V2_4 AS (
SELECT  V2.*,
        CASE WHEN TEXT_MESSAGE_ENROLL_IND = 'Y' THEN 1 ELSE 0 END AS TEXT_ENROLLED_IND,
        CASE WHEN PRFL.RXC_PATIENT_ID IS NOT NULL THEN 1 ELSE 0 END AS RX_TIED_IND
FROM    PROMISE_TIME_HISTORY_V2_3 AS V2
LEFT JOIN core_rx.curated_patient.patient AS PAT
    ON  V2.RXC_PATIENT_ID = PAT.RXC_PATIENT_ID
LEFT JOIN (SELECT DISTINCT RXC_PATIENT_ID FROM CORE_RX.CURATED_PERSON.DIGITAL_USER_PROFILE 
            WHERE   PRIMARY_TIE_TS IS NOT NULL
            AND     RXC_PATIENT_ID IS NOT NULL) AS PRFL
    ON  V2.RXC_PATIENT_ID = PRFL.RXC_PATIENT_ID
);





CREATE OR REPLACE TEMP TABLE PROMISE_TIME_HISTORY_V2_5 AS (
select * from PROMISE_TIME_HISTORY_V2_4
where 
IND_IN_HOO_IND = 1 -- SCRIPTS INDUCTED DURING HOO
);



CREATE OR REPLACE TEMPORARY TABLE PATIENT_HISTORY_RX AS ( 
SELECT DISTINCT
      PFILL.RXC_PATIENT_ID 
    , PFILL.RX_NBR 
    , PFILL.STORE_NBR 
    , PFILL.FILL_NBR
    , PFILL.PRESCRIPTION_FILL_TS 
    , PFILL.FILL_STATUS_CD
    , PFILL.POS_TXN_TS
    , PFILL.DAY_SUPPLY_QTY
    , DRG.GCN_SEQUENCE_NBR
    , DRG.NDC 
    , ONR.FIRST_ATTEMPT_ORDER_READY
    , ONR.TRANSACTION_START_TS
    , ONR.ONR_BFR_PRMS
    , LAG(PFILL.POS_TXN_TS) OVER(PARTITION BY PFILL.RXC_PATIENT_ID, DRG.GCN_SEQUENCE_NBR ORDER BY PFILL.PRESCRIPTION_FILL_TS) AS PREV_POS_TXN_TS
    , LAG(PFILL.DAY_SUPPLY_QTY) OVER(PARTITION BY PFILL.RXC_PATIENT_ID, DRG.GCN_SEQUENCE_NBR ORDER BY PFILL.PRESCRIPTION_FILL_TS) AS PREV_DAY_SUPPLY_QTY
    , DATEADD(DAY, PREV_DAY_SUPPLY_QTY, PREV_POS_TXN_TS) AS ARDD
    , DATEDIFF(DAY, PRESCRIPTION_FILL_TS, ARDD) AS DAY_SUPP_QTY_LEFT
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PFILL
LEFT JOIN CORE_RX.CURATED_PRODUCT.DRUG AS DRG
    ON PFILL.NDC = DRG.NDC 
LEFT JOIN APP_OMNIRX.OMNI_DL.ONR_FINAL_TBL AS ONR 
    ON ONR.NEW_RX_NBR = PFILL.RX_NBR 
    AND ONR.NEW_FILL_NBR = PFILL.FILL_NBR 
    AND ONR.STORE_NBR = PFILL.STORE_NBR
WHERE PRESCRIPTION_FILL_TS > DATEADD(DAY,-730,$START_DATE)
    AND (PFILL.RXC_PATIENT_ID, DRG.GCN_SEQUENCE_NBR) IN (SELECT DISTINCT RXC_PATIENT_ID, GCN_SEQUENCE_NBR FROM PROMISE_TIME_HISTORY_V2_5)
    AND FILL_STATUS_CD IN (6,7,9) --LOOKING FOR SOLD, WAITING BIN, RTS
);




CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_HISTORY_V3 AS ( 
SELECT  V2.*,
        PREV_POS_TXN_TS,
        PREV_DAY_SUPPLY_QTY,
        ARDD,
        DAY_SUPP_QTY_LEFT
FROM    PROMISE_TIME_HISTORY_V2_5 AS V2
LEFT JOIN PATIENT_HISTORY_RX AS RX
    ON  V2.STORE_NBR = RX.STORE_NBR
    AND V2.RX_NBR = RX.RX_NBR
    AND V2.FILL_NBR = RX.FILL_NBR
    AND V2.PRESCRIPTION_FILL_TS = RX.PRESCRIPTION_FILL_TS
    AND V2.RXC_PATIENT_ID = RX.RXC_PATIENT_ID
);



--GATHERING THE FINAL VERIFICATION TIMESTAMP FOR THESE RX.
CREATE OR REPLACE TEMPORARY TABLE PATIENT_HISTORY_FINAL_VERIFICATION_TS AS ( 
SELECT 
       X.RX_NBR 
     , X.FILL_NBR 
     , X.STORE_NBR
     , MAX(PACT.REC_EFF_TS) AS FINAL_VERF_TS
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_ACTIVITY AS PACT 
INNER JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_XREF AS X 
    ON PACT.RXC_PRESCRIPTION_FILL_ID = X.RXC_PRESCRIPTION_FILL_ID
INNER JOIN PATIENT_HISTORY_RX AS HIST
    ON HIST.RX_NBR = X.RX_NBR 
    AND HIST.STORE_NBR = X.STORE_NBR 
    AND HIST.FILL_NBR = X.FILL_NBR
WHERE 
    ACTIVITY_CD IN (4)
    AND PACT.REC_EFF_TS > DATEADD(DAY,-730,$START_DATE)
    GROUP BY 1,2,3
);



CREATE OR REPLACE TEMPORARY TABLE PATIENT_HISTORY_INDUCTION_TIME AS ( -- 11 mins
SELECT 
      X.RX_NBR 
    , X.FILL_NBR 
    , X.STORE_NBR 
    , MIN(PACT.REC_EFF_TS) AS INDUCTION_TS
FROM CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_ACTIVITY AS PACT 
INNER JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL_XREF AS X
    ON PACT.RXC_PRESCRIPTION_FILL_ID = X.RXC_PRESCRIPTION_FILL_ID
-- INNER JOIN PATIENT_HISTORY_RX AS BASE 
INNER JOIN PATIENT_HISTORY_RX AS BASE

    ON X.RX_NBR = BASE.RX_NBR 
    AND X.FILL_NBR = BASE.FILL_NBR 
    AND X.STORE_NBR = BASE.STORE_NBR 
WHERE PACT.REC_EFF_TS > DATEADD(DAY,-730,$START_DATE)
GROUP BY 1,2,3
);



--FINDING THE PATIENT'S HISTORY FOR EACH GCN ON DIFFERENT TIMELINES.
--COULD CHANGE THIS TO POS_TXN_TS. MAYBE LOOK INTO INSTANCES IN WHICH PATIENTS DO NOT COME BACK IN.

CREATE OR REPLACE TEMPORARY TABLE PATIENT_HISTORY_GCN_AGG AS ( 
SELECT 
      BASE.RXC_PATIENT_ID 
    , BASE.GCN_SEQUENCE_NBR 

    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED WITHIN 60-MINUTES OF INDUCTION FOR THE GCN.
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 12
                AND HIST.FILL_STATUS_CD IN (7)
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) < 60
                THEN HIST.RX_NBR 
                ELSE NULL END) AS ONE_YEAR_HISTORY_ARRIVED_WITHIN_60_MINUTES
    
    
    --SIX MONTH HISTORY
 
    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED WITHIN 60-MINUTES OF INDUCTION FOR THE GCN.
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 6
                AND HIST.FILL_STATUS_CD IN (7) 
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) < 60
                THEN HIST.RX_NBR 
                ELSE NULL END) AS SIX_MONTH_HISTORY_ARRIVED_WITHIN_60_MINUTES 

                
FROM PROMISE_TIME_HISTORY_V2_5 AS BASE
LEFT JOIN PATIENT_HISTORY_RX AS HIST 
    ON BASE.RXC_PATIENT_ID = HIST.RXC_PATIENT_ID 
    AND BASE.GCN_SEQUENCE_NBR = HIST.GCN_SEQUENCE_NBR
LEFT JOIN PATIENT_HISTORY_FINAL_VERIFICATION_TS AS HIST_VERF 
    ON HIST.RX_NBR = HIST_VERF.RX_NBR 
    AND HIST.STORE_NBR = HIST_VERF.STORE_NBR 
    AND HIST.FILL_NBR = HIST_VERF.FILL_NBR

LEFT JOIN PATIENT_HISTORY_INDUCTION_TIME AS HIST_IND
    ON HIST.RX_NBR = HIST_IND.RX_NBR 
    AND HIST.STORE_NBR = HIST_IND.STORE_NBR 
    AND HIST.FILL_NBR = HIST_IND.FILL_NBR
GROUP BY 1,2
);


-- ADDITIONAL HISTORY FEATURES  4 hours and next day plus
--------------------------------=
---------------------------------
create or replace temp table PATIENT_HISTORY_GCN_AGG_2 as (
SELECT 
      BASE.RXC_PATIENT_ID 
    , BASE.GCN_SEQUENCE_NBR 
    
   --ONE YEAR HISTORY

    
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 12
                AND HIST.FILL_STATUS_CD IN (7)
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) < 240
                THEN HIST.RX_NBR 
                ELSE NULL END) AS ONE_YEAR_HISTORY_ARRIVED_WITHIN_4_HOURS
    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED AFTER 24-HOURS OF INDUCTION FOR THE GCN
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 12
                AND HIST.FILL_STATUS_CD IN (7)
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) > 240
                THEN HIST.RX_NBR 
                ELSE NULL END) AS ONE_YEAR_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS



                , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 12
                AND HIST.FILL_STATUS_CD IN (7)
                AND DATEDIFF(DAY,HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) = 1 
                THEN HIST.RX_NBR 
                ELSE NULL END) AS ONE_YEAR_HISTORY_ARRIVED_NEXT_DAY
    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED AFTER 24-HOURS OF INDUCTION FOR THE GCN
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 12
                AND HIST.FILL_STATUS_CD IN (7)
                AND (DATEDIFF(DAY,HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) > 1 OR HIST.TRANSACTION_START_TS IS NULL)
                THEN HIST.RX_NBR 
                ELSE NULL END) AS ONE_YEAR_HISTORY_ARRIVED_AFTER_NEXT_DAY
  
    
    --SIX MONTH HISTORY
    
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 6
                AND HIST.FILL_STATUS_CD IN (7) 
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) < 240
                THEN HIST.RX_NBR 
                ELSE NULL END) AS SIX_MONTH_HISTORY_ARRIVED_WITHIN_4_HOURS 
    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED PAST 24-HOURS FOR THE SCRIPT.
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 6
                AND HIST.FILL_STATUS_CD IN (7)
                AND TO_DATE(HIST_IND.INDUCTION_TS) = TO_DATE(HIST.TRANSACTION_START_TS)
                AND DATEDIFF(MINUTE, HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) > 240
                THEN HIST.RX_NBR 
                ELSE NULL END) AS SIX_MONTH_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS



    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 6
                AND HIST.FILL_STATUS_CD IN (7) 
                AND DATEDIFF(DAY,HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) = 1 
                THEN HIST.RX_NBR 
                ELSE NULL END) AS SIX_MONTH_HISTORY_ARRIVED_NEXT_DAY 
    --FINDING THE # OF CASES IN WHICH THE PATIENT ARRIVED PAST 24-HOURS FOR THE SCRIPT.
    , COUNT(CASE 
            WHEN 
                HIST_VERF.FINAL_VERF_TS < BASE.INDUCTION_TS 
                AND DATEDIFF(MONTH, HIST_VERF.FINAL_VERF_TS, BASE.INDUCTION_TS) <= 6
                AND HIST.FILL_STATUS_CD IN (7)
                AND (DATEDIFF(DAY,HIST_IND.INDUCTION_TS, HIST.TRANSACTION_START_TS) > 1 OR HIST.TRANSACTION_START_TS IS NULL)
                THEN HIST.RX_NBR 
                ELSE NULL END) AS SIX_MONTH_HISTORY_ARRIVED_AFTER_NEXT_DAY
                
FROM PROMISE_TIME_HISTORY_V2_5 AS BASE
LEFT JOIN PATIENT_HISTORY_RX AS HIST 
    ON BASE.RXC_PATIENT_ID = HIST.RXC_PATIENT_ID 
    AND BASE.GCN_SEQUENCE_NBR = HIST.GCN_SEQUENCE_NBR
LEFT JOIN PATIENT_HISTORY_FINAL_VERIFICATION_TS AS HIST_VERF 
    ON HIST.RX_NBR = HIST_VERF.RX_NBR 
    AND HIST.STORE_NBR = HIST_VERF.STORE_NBR 
    AND HIST.FILL_NBR = HIST_VERF.FILL_NBR

LEFT JOIN PATIENT_HISTORY_INDUCTION_TIME AS HIST_IND
    ON HIST.RX_NBR = HIST_IND.RX_NBR 
    AND HIST.STORE_NBR = HIST_IND.STORE_NBR 
    AND HIST.FILL_NBR = HIST_IND.FILL_NBR
GROUP BY 1,2
);





CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_DATA_LAYER_VER_OCT24 AS (
SELECT 
      base.*
    , DATEDIFF(MINUTE, INDUCTION_TS, PATIENT_ARRIVAL_TIME) AS MINUTES_ELAPSED_INDUCTION_TO_PATIENT_ARRIVAL 
    , DATEDIFF(MINUTE, INDUCTION_TS, ORIGINAL_PROMISE_TIME) AS MINUTES_ELAPSED_ORIGINAL_PT_TO_INDUCTION 
    , DATEDIFF(MINUTE, ORIGINAL_PROMISE_TIME, PATIENT_ARRIVAL_TIME) AS MINUTES_ELAPSED_ORIGINAL_PT_TO_PATIENT_ARRIVAL  

    , GCN.ONE_YEAR_HISTORY_ARRIVED_WITHIN_60_MINUTES 

    , GCN.SIX_MONTH_HISTORY_ARRIVED_WITHIN_60_MINUTES 

FROM PROMISE_TIME_HISTORY_V3 AS BASE

LEFT JOIN PATIENT_HISTORY_GCN_AGG AS GCN
    ON BASE.RXC_PATIENT_ID = GCN.RXC_PATIENT_ID 
    AND BASE.GCN_SEQUENCE_NBR = GCN.GCN_SEQUENCE_NBR

);




CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_DATA_LAYER_VER_OCT24_V2 AS (
SELECT 
      base.*
    , GCN_2.ONE_YEAR_HISTORY_ARRIVED_WITHIN_4_HOURS
    , GCN_2.ONE_YEAR_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS
    , GCN_2.ONE_YEAR_HISTORY_ARRIVED_NEXT_DAY
    , GCN_2.ONE_YEAR_HISTORY_ARRIVED_AFTER_NEXT_DAY
    , GCN_2.SIX_MONTH_HISTORY_ARRIVED_WITHIN_4_HOURS
    , GCN_2.SIX_MONTH_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS
    , GCN_2.SIX_MONTH_HISTORY_ARRIVED_NEXT_DAY
    , GCN_2.SIX_MONTH_HISTORY_ARRIVED_AFTER_NEXT_DAY
FROM PROMISE_TIME_DATA_LAYER_VER_OCT24 AS BASE

LEFT JOIN PATIENT_HISTORY_GCN_AGG_2 AS GCN_2
    ON BASE.RXC_PATIENT_ID = GCN_2.RXC_PATIENT_ID 
    AND BASE.GCN_SEQUENCE_NBR = GCN_2.GCN_SEQUENCE_NBR
);



--- NEW FEATURES ADDED
----------------------
----------------------

-- CREATE OR REPLACE TEMPORARY TABLE RWP AS ( -- replced with dl_rx_operation.rx_ops_sandbox.RWP_C590078
-- SELECT  STORE_NO AS STORE_NBR,
--         FSCL_WK,
--         sum(DEN) AS TOTAL_SCRIPT,
--         sum(NUM) AS RWP_SCRIPTS,
--         ROUND(NULLIFZERO(RWP_SCRIPTS)/NULLIFZERO(TOTAL_SCRIPT), 4)AS RWP_PCT
-- FROM    APP_SOCS.SL_WCR_RPT.VW_CORE_WCR_RX AS RWP -- VW_CORE_WCR_RX_2023 for 2023 data
-- LEFT JOIN CORE_FSSC.CURATED_CALENDAR.FISCAL_WEEK AS FW
--         ON  FSCL_WK = FW.FISCAL_WEEK_NBR
-- WHERE   METRIC_ID = 2
--         and FSCL_WK between (extract(year from to_date($START_DATE)) || WEEK(to_date($START_DATE)) - 1) and (extract(year from to_date($END_DATE)) || WEEK(to_date($END_DATE)))
-- GROUP BY 1,2
-- );

----------------------
----------------------


CREATE OR REPLACE TEMPORARY TABLE PROMISE_TIME_DATA_LAYER AS (
SELECT  V2.*,
        DAYOFWEEK(INDUCTION_TS) AS INDUCTION_DAY_OF_WEEK,
        HOUR(INDUCTION_TS) AS INDUCTION_HOUR,
        LOCATION_TYPE_CD,
        RWP_PCT
FROM   PROMISE_TIME_DATA_LAYER_VER_OCT24_V2 AS V2
LEFT JOIN CORE_FSSC.CURATED_LOCATION.STORE AS STR
    ON  V2.STORE_NBR = STR.STORE_NBR
LEFT JOIN dl_rx_operation.rx_ops_sandbox.RWP_C590078 AS RWP
    ON  V2.STORE_NBR = RWP.STORE_NBR

    and (extract(year from to_date(INDUCTION_TS)) || LPAD(WEEK(to_date(INDUCTION_TS)),2,'0')) = (RWP.FSCL_WK - 1) -- prev week RWP 
);



--##################################

CREATE OR REPLACE TEMPORARY TABLE ACUTE_MAIN AS (
SELECT  PRM.*,
        CASE WHEN ACUTE_IND <> 'Y' AND PREV_POS_TXN_TS IS NOT NULL THEN 'MAINT-RECURR'
             WHEN ACUTE_IND <> 'Y' AND PREV_POS_TXN_TS IS NULL THEN 'MAINT'
        ELSE 'ACUTE' END AS SCRIPT_TYPE,
FROM    PROMISE_TIME_DATA_LAYER AS PRM
);


CREATE OR REPLACE TEMPORARY TABLE DYNAMIC_PROMISE_TIME_DATA_LAYER_TEST_V2 AS (
select PRT.*,
       COUNT(1) OVER(PARTITION BY STORE_NBR, RXC_Patient_ID, ORIGINAL_PROMISE_TIME) AS SCRIPTS_IN_BUNDLE,
       SUM(CASE WHEN SCRIPT_TYPE = 'ACUTE' THEN 1 ELSE 0 END) OVER(PARTITION BY STORE_NBR, RXC_Patient_ID, ORIGINAL_PROMISE_TIME) AS ACUTES_IN_BUNDLE,
       CASE WHEN SCRIPTS_IN_BUNDLE>1 THEN 1 ELSE 0 END AS HAS_BUNDLE_IND,
       CASE WHEN HAS_BUNDLE_IND = 0 THEN 'NOT A BUNDLE'
             WHEN HAS_BUNDLE_IND = 1 AND ACUTES_IN_BUNDLE >= 1 THEN 'BUNDLE WITH ACUTE'
             WHEN HAS_BUNDLE_IND = 1 AND ACUTES_IN_BUNDLE = 0 THEN 'BUNDLE WITH NO ACUTE'
        END AS BUNDLE_TYPE
from ACUTE_MAIN as PRT
);




CREATE OR REPLACE TEMPORARY TABLE SCHEDULE_FILL_IND AS (
SELECT  PRM.*
        , PF.SOURCE_CD
        , PF.CREATE_BY_NM
        , PF.COPAY_COINSURANCE_AMT
        , PF.RX_ORIGIN_CD
        , PF.VERIFIED_TS
        -- METHOD 1
        , CASE WHEN PF.CREATE_BY_NM LIKE '%rri%' OR PF.CREATE_BY_NM LIKE '%raz%' THEN 1 ELSE 0 END AS SCHEDULED_batch_IND
        -- METHOD 2
        , CASE WHEN SOURCE_CD IN (6,19,24,25,31) THEN 1 ELSE 0 END AS SCHEDULED_SOURCE_IND
        -- METHOD 3
        , LAG(SCHEDULE_FILL_REASON_ID) OVER(PARTITION BY PF.STORE_NBR, PF.RX_NBR ORDER BY PF.FILL_NBR) AS PREV_SCHEDULE_RSN
        , CASE WHEN PREV_SCHEDULE_RSN IS NOT NULL THEN 1 ELSE 0 END AS SCHEDULED_LAG_IND
        -- FINAL SCHEDULED IND
        , CASE WHEN SCHEDULED_LAG_IND = 1 OR SCHEDULED_SOURCE_IND = 1 OR SCHEDULED_BATCH_IND = 1 THEN 1 ELSE 0 END AS SCHEDULED_FILL_IND


FROM    DYNAMIC_PROMISE_TIME_DATA_LAYER_TEST_V2 AS PRM
LEFT JOIN CORE_RX.CURATED_SCRIPT.PRESCRIPTION_FILL AS PF
    ON  PRM.STORE_NBR = PF.STORE_NBR
    AND PRM.RX_NBR = PF.RX_NBR
    AND PRM.FILL_NBR = PF.FILL_NBR
    AND PRM.RXC_PRESCRIPTION_FILL_ID = PF.RXC_PRESCRIPTION_FILL_ID
);




--- NEW FEATURES ADDED 2 --------------------------------------------


CREATE OR REPLACE TEMPORARY TABLE WEEKDAY_STR AS (
SELECT  STORE_NBR,
        (CASE WHEN MON_OPEN_TIME_TXT NOT LIKE 'CLOSED' then 1 ELSE 0 END + 
            CASE when TUE_OPEN_TIME_TXT NOT LIKE 'CLOSED' then 1 ELSE 0 END +
            CASE WHEN WED_OPEN_TIME_TXT NOT LIKE 'CLOSED' then 1 ELSE 0 END +
            CASE when THU_OPEN_TIME_TXT NOT LIKE 'CLOSED' then 1 ELSE 0 END +
            CASE when FRI_OPEN_TIME_TXT NOT LIKE 'CLOSED' then 1 ELSE 0 END
            ) as WEEK_OPEN_DAYS,
        CASE WHEN WEEK_OPEN_DAYS = 5 THEN 1 ELSE 0 END AS WEEK_OPEN_IND
        
FROM CORE_RX.CURATED_LOCATION.STORE AS STR
);


-- ---- STORE HOO GROUP
CREATE OR REPLACE TEMPORARY TABLE STORE_HOO_GROUP AS (
    WITH STORE_HOO_BUCKET AS (
    SELECT  STORE_NBR
            ,STR.MON_OPEN_TIME_TXT
            ,STR.MON_CLOSE_TIME_TXT
            ,STR.TUE_OPEN_TIME_TXT
            ,STR.TUE_CLOSE_TIME_TXT
            ,STR.WED_OPEN_TIME_TXT
            ,STR.WED_CLOSE_TIME_TXT
            ,STR.THU_OPEN_TIME_TXT
            ,STR.THU_CLOSE_TIME_TXT
            ,STR.FRI_OPEN_TIME_TXT
            ,STR.FRI_CLOSE_TIME_TXT
            ,SUM(1) OVER(PARTITION BY STR.MON_OPEN_TIME_TXT, STR.MON_CLOSE_TIME_TXT, STR.TUE_OPEN_TIME_TXT, STR.TUE_CLOSE_TIME_TXT, STR.WED_OPEN_TIME_TXT, STR.WED_CLOSE_TIME_TXT,STR.THU_OPEN_TIME_TXT, STR.THU_CLOSE_TIME_TXT, STR.FRI_OPEN_TIME_TXT, STR.FRI_CLOSE_TIME_TXT) AS HOO_RANK
    FROM CORE_RX.CURATED_LOCATION.STORE AS STR
    WHERE STR.RX_CLOSE_DT IS NULL
        AND STR.MON_CLOSE_TIME_TXT IS NOT NULL
    )
    
    SELECT  STORE_NBR,
            DENSE_RANK() OVER(PARTITION BY 1 ORDER BY HOO_RANK DESC) AS HOO_RANK
    FROM    STORE_HOO_BUCKET
);


CREATE OR REPLACE TEMPORARY TABLE BASE_SCRIPT_4 AS (
SELECT  V3.*,
        GRP.HOO_RANK,
        PR.PRESCRIBER_LAST_NM,
        PR.PRESCRIBER_FIRST_NM,
        PR.ADDRESS_LINE1,
        PR.ADDRESS_LINE2,
        PR.CITY_NM,
        PR.STATE_PROVINCE_NM,
        PR.POSTAL_CD,
        PR.NPI_NBR,
        PR.SPECIALTY_CD,
        PR.DEA_NBR,
        PR.STATE_LICENSE_NBR,
        PR.PRESCRIBER_TYPE_CD,

        PRSC.SPECIALTY_TXT,
        OS.PRESCRIBER_ROLE_CD,
        OS.PRIMARY_TAXONOMY_CODE,
        OS.CLASSIFICATION,
        OS.SPECIALIZATION,

        DRG.GENERIC_IND,
        WS.WEEK_OPEN_IND,
        
FROM    SCHEDULE_FILL_IND AS V3

LEFT JOIN STORE_HOO_GROUP AS GRP
    ON  V3.STORE_NBR = GRP.STORE_NBR
LEFT JOIN CORE_RX.CURATED_SCRIPT.ERX_OUTCOME AS OC --dl_rx_operation.rx_ops_sandbox.erxout_final_c590078 AS OC
        ON  V3.STORE_NBR = OC.STORE_NBR
        AND V3.RX_NBR = OC.RX_NBR
        AND V3.FILL_NBR = 0
LEFT JOIN CORE_RX.CURATED_SCRIPT.ERX_SEGMENT_PRESCRIBER AS PR
    ON  OC.MESSAGE_ID = PR.MESSAGE_ID
    AND TO_DATE(OC.TRANSACTION_TS) = TO_DATE(PR.TRANSACTION_TS)
    AND PR.PRESCRIBER_ROLE_CD = 'Prescriber'
    and PR.message_type_cd in ('NewRx', 'RxChangeResponse', 'RxRenewalResponse', 'RefillRenewalResponse')
    and PR.NPI_NBR is not null



LEFT JOIN  WEEKDAY_STR AS WS
        ON  V3.STORE_NBR = WS.STORE_NBR
LEFT JOIN CORE_RX.CURATED_PRESCRIBER.PRESCRIBER AS PRSC
    ON V3.RXC_PRESCRIBER_ID = PRSC.RXC_PRESCRIBER_ID

LEFT JOIN CORE_RX.CURATED_PRODUCT.DRUG AS DRG --THIS IS THE MAIN DRUG TABLE
        ON V3.NDC = DRG.NDC

LEFT JOIN  dl_rx_operation.rx_ops_sandbox.erxout_final_sep2025_c590078 as OS
        ON  V3.STORE_NBR = OS.STORE_NBR
        AND V3.RX_NBR = OS.RX_NBR
        AND V3.FILL_NBR = OS.FILL_NBR

        
QUALIFY ROW_NUMBER() OVER(PARTITION BY V3.STORE_NBR, V3.RX_NBR, V3.FILL_NBR ORDER BY OC.TRANSACTION_TS) = 1

);


---- TESTING NEXT DAY OPEN DATE
CREATE OR REPLACE TEMPORARY TABLE BASE_SCRIPT_WIITH_NEXT_OPEN_DATE AS (
SELECT  BASE.*,
         DATEADD(day, 
                CASE DAYOFWEEK(INDUCTION_TS_LOCAL) 
                        WHEN 0 THEN -- Sunday
                            CASE 
                                WHEN MON_CLOSED=0 THEN 1
                                WHEN TUE_CLOSED=0 THEN 2
                                WHEN WED_CLOSED=0 THEN 3
                                WHEN THU_CLOSED=0 THEN 4
                                WHEN FRI_CLOSED=0 THEN 5
                                WHEN SAT_CLOSED=0 THEN 6
                                WHEN SUN_CLOSED=0 THEN 7 -- next Sunday
                                ELSE 7 -- if all days are closed, add 7 days (next week)
                            END
                        WHEN 1 THEN -- Monday
                          CASE 
                                WHEN TUE_CLOSED=0 THEN 1
                                WHEN WED_CLOSED=0 THEN 2
                                WHEN THU_CLOSED=0 THEN 3
                                WHEN FRI_CLOSED=0 THEN 4
                                WHEN SAT_CLOSED=0 THEN 5
                                WHEN SUN_CLOSED=0 THEN 6
                                WHEN MON_CLOSED=0 THEN 7 -- next Monday
                                ELSE 7
                            END
                        WHEN 2 THEN -- Tuesday
                          CASE 
                                WHEN WED_CLOSED=0 THEN 1
                                WHEN THU_CLOSED=0 THEN 2
                                WHEN FRI_CLOSED=0 THEN 3
                                WHEN SAT_CLOSED=0 THEN 4
                                WHEN SUN_CLOSED=0 THEN 5
                                WHEN MON_CLOSED=0 THEN 6
                                WHEN TUE_CLOSED=0 THEN 7 -- next Tuesday
                                ELSE 7
                            END
                        WHEN 3 THEN -- Wednesday
                          CASE 
                                WHEN THU_CLOSED=0 THEN 1
                                WHEN FRI_CLOSED=0 THEN 2
                                WHEN SAT_CLOSED=0 THEN 3
                                WHEN SUN_CLOSED=0 THEN 4
                                WHEN MON_CLOSED=0 THEN 5
                                WHEN TUE_CLOSED=0 THEN 6
                                WHEN WED_CLOSED=0 THEN 7 -- next Wednesday
                                ELSE 7
                            END
                        WHEN 4 THEN -- Thursday
                          CASE 
                                WHEN FRI_CLOSED=0 THEN 1
                                WHEN SAT_CLOSED=0 THEN 2
                                WHEN SUN_CLOSED=0 THEN 3
                                WHEN MON_CLOSED=0 THEN 4
                                WHEN TUE_CLOSED=0 THEN 5
                                WHEN WED_CLOSED=0 THEN 6
                                WHEN THU_CLOSED=0 THEN 7 -- next Thursday
                                ELSE 7
                            END
                        WHEN 5 THEN -- Friday
                          CASE 
                                WHEN SAT_CLOSED=0 THEN 1
                                WHEN SUN_CLOSED=0 THEN 2
                                WHEN MON_CLOSED=0 THEN 3
                                WHEN TUE_CLOSED=0 THEN 4
                                WHEN WED_CLOSED=0 THEN 5
                                WHEN THU_CLOSED=0 THEN 6
                                WHEN FRI_CLOSED=0 THEN 7 -- next Friday
                                ELSE 7
                            END
                        WHEN 6 THEN -- Saturday
                          CASE 
                                WHEN SUN_CLOSED=0 THEN 1
                                WHEN MON_CLOSED=0 THEN 2
                                WHEN TUE_CLOSED=0 THEN 3
                                WHEN WED_CLOSED=0 THEN 4
                                WHEN THU_CLOSED=0 THEN 5
                                WHEN FRI_CLOSED=0 THEN 6
                                WHEN SAT_CLOSED=0 THEN 7 -- next Saturday
                                ELSE 7
                            END
                        END, 
                DATE(INDUCTION_TS_LOCAL)) AS IND_NEXT_DAY_ACT,
                
            dayname(IND_NEXT_DAY_ACT) AS IND_NEXT_DAY_OF_WEEK_ACT,
            
            CASE WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Sun' AND SUN_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SUN_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN CONCAT(TO_DATE(IND_NEXT_DAY_ACT),' ',TIME(SUN_CLOSE_TIME_TXT))::TIMESTAMP           
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Mon' AND MON_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND MON_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.MON_CLOSE_TIME_TXT):: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Tue' AND TUE_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND TUE_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.TUE_CLOSE_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Wed' AND WED_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND WED_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.WED_CLOSE_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Thu' AND THU_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND THU_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.THU_CLOSE_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Fri' AND FRI_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND FRI_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.FRI_CLOSE_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Sat' AND SAT_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SAT_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.SAT_CLOSE_TIME_TXT) :: TIME)
            END AS STORE_CLOSE_TIME_NEXT_DAY_ACT,
        
            CASE WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Sun' AND SUN_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SUN_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN CONCAT(TO_DATE(IND_NEXT_DAY_ACT),' ',TIME(SUN_OPEN_TIME_TXT))::TIMESTAMP           
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Mon' AND MON_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND MON_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.MON_OPEN_TIME_TXT):: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Tue' AND TUE_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND TUE_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.TUE_OPEN_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Wed' AND WED_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND WED_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.WED_OPEN_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Thu' AND THU_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND THU_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.THU_OPEN_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Fri' AND FRI_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND FRI_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.FRI_OPEN_TIME_TXT) :: TIME)
             WHEN IND_NEXT_DAY_OF_WEEK_ACT LIKE 'Sat' AND SAT_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SAT_OPEN_TIME_TXT NOT LIKE '24 HOURS'
                THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_DAY_ACT):: DATE,time(STR.SAT_OPEN_TIME_TXT) :: TIME)
            END AS STORE_OPEN_TIME_NEXT_DAY_ACT,

            DATEADD(day, 
                CASE DAYOFWEEK(IND_NEXT_DAY_ACT) 
                        WHEN 0 THEN -- Sunday
                            CASE 
                                WHEN MON_CLOSED=0 THEN 1
                                WHEN TUE_CLOSED=0 THEN 2
                                WHEN WED_CLOSED=0 THEN 3
                                WHEN THU_CLOSED=0 THEN 4
                                WHEN FRI_CLOSED=0 THEN 5
                                WHEN SAT_CLOSED=0 THEN 6
                                WHEN SUN_CLOSED=0 THEN 7 -- next Sunday
                                ELSE 7 -- if all days are closed, add 7 days (next week)
                            END
                        WHEN 1 THEN -- Monday
                          CASE 
                                WHEN TUE_CLOSED=0 THEN 1
                                WHEN WED_CLOSED=0 THEN 2
                                WHEN THU_CLOSED=0 THEN 3
                                WHEN FRI_CLOSED=0 THEN 4
                                WHEN SAT_CLOSED=0 THEN 5
                                WHEN SUN_CLOSED=0 THEN 6
                                WHEN MON_CLOSED=0 THEN 7 -- next Monday
                                ELSE 7
                            END
                        WHEN 2 THEN -- Tuesday
                          CASE 
                                WHEN WED_CLOSED=0 THEN 1
                                WHEN THU_CLOSED=0 THEN 2
                                WHEN FRI_CLOSED=0 THEN 3
                                WHEN SAT_CLOSED=0 THEN 4
                                WHEN SUN_CLOSED=0 THEN 5
                                WHEN MON_CLOSED=0 THEN 6
                                WHEN TUE_CLOSED=0 THEN 7 -- next Tuesday
                                ELSE 7
                            END
                        WHEN 3 THEN -- Wednesday
                          CASE 
                                WHEN THU_CLOSED=0 THEN 1
                                WHEN FRI_CLOSED=0 THEN 2
                                WHEN SAT_CLOSED=0 THEN 3
                                WHEN SUN_CLOSED=0 THEN 4
                                WHEN MON_CLOSED=0 THEN 5
                                WHEN TUE_CLOSED=0 THEN 6
                                WHEN WED_CLOSED=0 THEN 7 -- next Wednesday
                                ELSE 7
                            END
                        WHEN 4 THEN -- Thursday
                          CASE 
                                WHEN FRI_CLOSED=0 THEN 1
                                WHEN SAT_CLOSED=0 THEN 2
                                WHEN SUN_CLOSED=0 THEN 3
                                WHEN MON_CLOSED=0 THEN 4
                                WHEN TUE_CLOSED=0 THEN 5
                                WHEN WED_CLOSED=0 THEN 6
                                WHEN THU_CLOSED=0 THEN 7 -- next Thursday
                                ELSE 7
                            END
                        WHEN 5 THEN -- Friday
                          CASE 
                                WHEN SAT_CLOSED=0 THEN 1
                                WHEN SUN_CLOSED=0 THEN 2
                                WHEN MON_CLOSED=0 THEN 3
                                WHEN TUE_CLOSED=0 THEN 4
                                WHEN WED_CLOSED=0 THEN 5
                                WHEN THU_CLOSED=0 THEN 6
                                WHEN FRI_CLOSED=0 THEN 7 -- next Friday
                                ELSE 7
                            END
                        WHEN 6 THEN -- Saturday
                          CASE 
                                WHEN SUN_CLOSED=0 THEN 1
                                WHEN MON_CLOSED=0 THEN 2
                                WHEN TUE_CLOSED=0 THEN 3
                                WHEN WED_CLOSED=0 THEN 4
                                WHEN THU_CLOSED=0 THEN 5
                                WHEN FRI_CLOSED=0 THEN 6
                                WHEN SAT_CLOSED=0 THEN 7 -- next Saturday
                                ELSE 7
                            END
                        END, 
                DATE(IND_NEXT_DAY_ACT)) AS IND_NEXT_TO_NEXT_DAY_ACT,
                dayname(IND_NEXT_TO_NEXT_DAY_ACT) AS IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT,

                
                CASE WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Sun' AND SUN_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SUN_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT),' ',TIME(SUN_CLOSE_TIME_TXT))::TIMESTAMP           
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Mon' AND MON_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND MON_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.MON_CLOSE_TIME_TXT):: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Tue' AND TUE_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND TUE_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.TUE_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Wed' AND WED_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND WED_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.WED_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Thu' AND THU_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND THU_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.THU_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Fri' AND FRI_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND FRI_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.FRI_CLOSE_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Sat' AND SAT_CLOSE_TIME_TXT NOT LIKE 'CLOSED' AND SAT_CLOSE_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.SAT_CLOSE_TIME_TXT) :: TIME)
        END AS STORE_CLOSE_TIME_NEXT_TO_NEXT_DAY_ACT,
        
        CASE WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Sun' AND SUN_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SUN_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN CONCAT(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT),' ',TIME(SUN_OPEN_TIME_TXT))::TIMESTAMP           
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Mon' AND MON_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND MON_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.MON_OPEN_TIME_TXT):: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Tue' AND TUE_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND TUE_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.TUE_OPEN_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Wed' AND WED_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND WED_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.WED_OPEN_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Thu' AND THU_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND THU_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.THU_OPEN_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Fri' AND FRI_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND FRI_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.FRI_OPEN_TIME_TXT) :: TIME)
         WHEN IND_NEXT_TO_NEXT_DAY_OF_WEEK_ACT LIKE 'Sat' AND SAT_OPEN_TIME_TXT NOT LIKE 'CLOSED' AND SAT_OPEN_TIME_TXT NOT LIKE '24 HOURS'
            THEN TIMESTAMP_NTZ_FROM_PARTS(TO_DATE(IND_NEXT_TO_NEXT_DAY_ACT):: DATE,time(STR.SAT_OPEN_TIME_TXT) :: TIME)
        END AS STORE_OPEN_TIME_NEXT_TO_NEXT_DAY_ACT 

                
FROM    BASE_SCRIPT_4 AS BASE
INNER JOIN (SELECT *
                        ,CASE WHEN SUN_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS SUN_CLOSED
                        ,CASE WHEN MON_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS MON_CLOSED
                        ,CASE WHEN TUE_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS TUE_CLOSED
                        ,CASE WHEN WED_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS WED_CLOSED
                        ,CASE WHEN THU_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS THU_CLOSED
                        ,CASE WHEN FRI_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS FRI_CLOSED
                        ,CASE WHEN SAT_CLOSE_TIME_TXT LIKE 'CLOSED' THEN 1 ELSE 0 END AS SAT_CLOSED
                FROM CORE_RX.CURATED_LOCATION.STORE) AS STR 
    ON BASE.STORE_NBR = STR.STORE_NBR
);



CREATE OR REPLACE TEMP TABLE DYNAMIC_PROMISE_TIME_DATA_LAYER_TEST_V2_C590078_RTOR AS (
SELECT 
      base.*
      , POS_PRIOR_TO_RTOR
      ,POS_PRIOR_TO_RTOR_PCT
FROM BASE_SCRIPT_WIITH_NEXT_OPEN_DATE AS BASE

LEFT JOIN dl_rx_operation.rx_ops_sandbox.POS_PRIOR_TO_RTOR AS RTOR
    ON BASE.RXC_PATIENT_ID = RTOR.RXC_PATIENT_ID 
    AND BASE.GCN_SEQUENCE_NBR = RTOR.GCN_SEQUENCE_NBR
);



-----------===============




CREATE OR REPLACE TABLE dl_rx_operation.rx_ops_sandbox.promise_time_class_model_v4_10162025_C590078 as (
    SELECT 
        PAT_ARRVL_DUR,
        ACT_PAT_ARRVL_DUR,
        AGE_GROUP,
        PATIENT_ARRIVAL_TIME,
        PAT_ARRVL_BUCKET,
        INDUCTION_TS_LOCAL,
        PATIENT_ARRIVAL_TIME_LOCAL,
        dayname(INDUCTION_TS_LOCAL) AS INDUCTION_LOCAL_DAY_NAME,
        DAY(INDUCTION_TS_LOCAL) AS INDUCTION_LOCAL_DOM, 
        HOUR(INDUCTION_TS_LOCAL) AS INDUCTION_LOCAL_HOUR, 
        MINUTE(INDUCTION_TS_LOCAL) AS INDUCTION_LOCAL_MIN,
        DAYOFWEEK(INDUCTION_TS_LOCAL) AS INDUCTION_LOCAL_DOW, 
        DAY_SUPPLY_QTY,
        PTNT_AGE,
        GENDER_CD,
        ONE_YEAR_HISTORY_ARRIVED_WITHIN_60_MINUTES,
        SIX_MONTH_HISTORY_ARRIVED_WITHIN_60_MINUTES,
        DAY_SUPP_QTY_LEFT,
        HISTORY_IND,
                DEA_NBR,        
        CASE    WHEN NULLIF(DEA_CD, '') IN (0,6,7) THEN 1
                WHEN NULLIF(DEA_CD, '') NOT IN (0,6,7) THEN 0
        END AS DEA_CD_0_6_7,
        CASE    WHEN NULLIF(DEA_CD, '') IN (3,4,5) THEN 1
                WHEN NULLIF(DEA_CD, '') NOT IN (3,4,5) THEN 0
        END AS DEA_CD_3_4_5,
        CASE    WHEN NULLIF(DEA_CD, '') = 2 THEN 1
                WHEN NULLIF(DEA_CD, '') != 2 THEN 0
        END AS DEA_CD_2,
        THERAPEUTIC_CLASS_CD,
        LABEL_NM,
        NDC,
        SCRIPT_TYPE,
        TIMEZONE_DSC,
        LOCATION_TYPE_CD,
        RWP_PCT,
        CASE    WHEN INDUCTION_LOCAL_HOUR <12 THEN 'MORNING'
                WHEN INDUCTION_LOCAL_HOUR BETWEEN 12 AND 15 THEN 'EARLY_AFTERNOON'
                WHEN INDUCTION_LOCAL_HOUR BETWEEN 15 AND 18 THEN 'LATE_AFTERNOON'
                WHEN INDUCTION_LOCAL_HOUR > 18 THEN 'EVENING'
        END AS TIME_SLOT,

        SCRIPTS_IN_BUNDLE,
        HAS_BUNDLE_IND,
        scheduled_fill_ind,
        SPECIALTY_TXT,
        FACILITY_TYP_DSC,
        PRESCRIBER_STORE_DISTANCE_NBR,
        PATIENT_PRESCRIBER_DISTANCE_NBR,
        PATIENT_STORE_DISTANCE_NBR,
        SPECIALTY_CD,
        ADDRESS_LINE1,
        ADDRESS_LINE2,
        CITY_NM,
        STATE_PROVINCE_NM,
        POSTAL_CD,
        PRESCRIBER_FIRST_NM,
        PRESCRIBER_LAST_NM,
        NPI_NBR,
        PRIMARY_TAXONOMY_CODE,
        CLASSIFICATION,
        SPECIALIZATION,
        COPAY_COINSURANCE_AMT,
        RX_NBR, 
        STORE_NBR, 
        FILL_NBR, 
        PRESCRIPTION_FILL_TS,
        RXC_PRESCRIPTION_FILL_ID, -- TEST THE RECORD COUNT WITH THIS
        DAY_SUPPLY_QTY_THREE_OR_LESS_IND, --It's directly applied 30 min of Prt
        STORE_ZIP_CD,
        TEXT_ENROLLED_IND,
        RX_TIED_IND,
        RXC_PATIENT_ID,
        week_open_ind,
        DATEDIFF(MINUTE,INDUCTION_TS_LOCAL, STORE_CLOSE_TIME_LOCAL_IND) as IND2CLOSE,
        STATE_LICENSE_NBR,
        STORE_ADDR1_TXT,
        STORE_CITY_NM,
        STORE_CLOSE_TIME_LOCAL_IND,
        STORE_CLOSE_TIME_NEXT_DAY_ACT,
        STORE_CLOSE_TIME_NEXT_TO_NEXT_DAY_ACT,
        STORE_OPEN_TIME_LOCAL_IND,
        STORE_OPEN_TIME_NEXT_DAY_ACT,
        STORE_OPEN_TIME_NEXT_TO_NEXT_DAY_ACT,
        STORE_STATE_CD,
        CASE WHEN CREATE_BY_NM LIKE '%rri%' OR CREATE_BY_NM LIKE '%raz%' OR CREATE_BY_NM LIKE '%SWO%'
        THEN 'BATCH' ELSE 'NON-BATCH' END AS BATCH_SCRIPTS,
        BUNDLE_TYPE,
        GCN_SEQUENCE_NBR,
        GENERIC_IND,
        ONE_YEAR_HISTORY_ARRIVED_AFTER_NEXT_DAY,
        ONE_YEAR_HISTORY_ARRIVED_NEXT_DAY,
        ONE_YEAR_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS,
        ONE_YEAR_HISTORY_ARRIVED_WITHIN_4_HOURS,
        ORIGINAL_PROMISE_TIME_LOCAL,
        RX_ORIGIN_CD,
        SIX_MONTH_HISTORY_ARRIVED_AFTER_NEXT_DAY,
        SIX_MONTH_HISTORY_ARRIVED_NEXT_DAY,
        SIX_MONTH_HISTORY_ARRIVED_SAME_DAY_PAST_4_HOURS,
        SIX_MONTH_HISTORY_ARRIVED_WITHIN_4_HOURS,
        SOURCE_CD,
        POS_PRIOR_TO_RTOR,
        POS_PRIOR_TO_RTOR_PCT
    
    FROM DYNAMIC_PROMISE_TIME_DATA_LAYER_TEST_V2_C590078_RTOR


    WHERE   IND_DAY = 'WEEKDAY' -- WEEKDAY INDUCTION SCRIPTS ONLY
    AND NEW_RX_IND = 0 -- FILTERING TO TRUE NEW FILLS, HAS BEEN APPLIED ALREADY
    AND ACTION_NOTE_IND = 0 -- REMOVING ACTION NOTE SCRIPTS
    AND IND_IN_HOO_IND = 1 -- SCRIPTS INDUCTED DURING HOO
    AND (INDUCTION_TS_LOCAL < PATIENT_ARRIVAL_TIME_LOCAL OR PATIENT_ARRIVAL_TIME_LOCAL IS NULL)-- REMOVING ARRIVAL BEFORE IND
    AND HOO_RANK <= 10 -- TOP 10 HOO
    AND NPI_NBR IS NOT NULL
    AND INDUCTION_TS_LOCAL BETWEEN  DATE'2024-08-31' AND DATE'2025-08-30'
        );


--- TRAIN AND VLAIDATION SETS
CREATE OR REPLACE TABLE dl_rx_operation.rx_ops_sandbox.PATIENT_ARRVL_TRAINING_SET_C590078 AS ( 
SELECT * FROM  dl_rx_operation.rx_ops_sandbox.promise_time_class_model_v4_10162025_C590078
WHERE RXC_PATIENT_ID NOT IN (SELECT DISTINCT RXC_PATIENT_ID FROM DL_RX_OPERATION.RX_OPS_SANDBOX.PATIENT_ARRVL_VALIDATION_SET_H1)
AND INDUCTION_TS_LOCAL BETWEEN  DATE'2024-08-31' AND DATE'2025-08-30'
QUALIFY ROW_NUMBER() OVER (ORDER BY RANDOM()) <= 5000000
);

SELECT COUNT(*) FROM DL_RX_OPERATION.RX_OPS_SANDBOX.PATIENT_ARRVL_TRAINING_SET_C590078;

SELECT  MONTH(INDUCTION_TS_LOCAL),
        COUNT(*),
        SUM(CASE WHEN PATIENT_ARRIVAL_TIME_LOCAL IS NOT NULL THEN 1 ELSE 0 END) AS PAT_ARRIVAL_SCRIPTS,
        SUM(CASE WHEN PATIENT_ARRIVAL_TIME_LOCAL IS NULL THEN 1 ELSE 0 END) AS NO_ARRIVAL_SCRIPTS
FROM    DL_RX_OPERATION.RX_OPS_SANDBOX.PATIENT_ARRVL_TRAINING_SET_C590078
GROUP BY 1
ORDER BY 1;


CREATE OR REPLACE TABLE dl_rx_operation.rx_ops_sandbox.PATIENT_ARRVL_VALIDATION_SET_C590078 AS ( 
SELECT * FROM  dl_rx_operation.rx_ops_sandbox.promise_time_class_model_v4_10162025_C590078
WHERE RXC_PATIENT_ID NOT IN (SELECT DISTINCT RXC_PATIENT_ID FROM dl_rx_operation.rx_ops_sandbox.PATIENT_ARRVL_TRAINING_SET_C590078)
AND INDUCTION_TS_LOCAL BETWEEN  DATE'2024-08-31' AND DATE'2025-08-30'
QUALIFY ROW_NUMBER() OVER (ORDER BY RANDOM()) <= 500000
);

SELECT COUNT(*) FROM DL_RX_OPERATION.RX_OPS_SANDBOX.PATIENT_ARRVL_VALIDATION_SET_C590078;

SELECT MONTH(INDUCTION_TS_LOCAL),
        count(*)
from   DL_RX_OPERATION.RX_OPS_SANDBOX.PATIENT_ARRVL_VALIDATION_SET_C590078 --VALIDATION_SET_TEST
group by 1
ORDER BY 1;



