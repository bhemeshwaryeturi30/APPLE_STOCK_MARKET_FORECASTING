

Weekly Duplicate eRx Detection

This repository contains the Snowflake SQL workflow for identifying and analyzing potential duplicate electronic prescriptions (eRx) received across retail pharmacy stores. The process isolates duplicate PPI Message IDs sent from prescribers within the same store and time window, ensuring that duplicate prescription fills are flagged, recorded, and reviewed before dispensing.

⸻

Overview

The Weekly Duplicate eRx workflow scans eRx data from the previous seven days to detect duplicate prescription messages that share the same PPI Message ID and store number. These potential duplicates are captured and logged into the historical tracking table DUPLICATE_PPI_HIST to prevent redundant analysis in future runs.

The process involves four main steps:
	1.	Extracting recent eRx messages.
	2.	Filtering and identifying duplicates using partition logic.
	3.	Enriching results with fill, patient, drug, and store details.
	4.	Appending unique message IDs to the historical log for traceability.

This routine supports pharmacy operations by reducing data redundancies, minimizing potential fill errors, and maintaining eRx data integrity across systems.

⸻

Setup and Variables

Before running the workflow, connect to the Snowflake environment and ensure access to the following schemas and objects:
	•	CORE_RX.CURATED_SCRIPT (Prescription and Fill tables)
	•	CORE_RX.CURATED_PRODUCT (Drug data)
	•	CORE_RX.CURATED_PATIENT (Patient master)
	•	CORE_RX.CURATED_LOCATION (Store metadata)
	•	DL_RX_OPERATION.RX_OPS_SANDBOX (Sandbox and historical tracking tables)

The script automatically analyzes prescriptions from the past 7 days using date filters on both LAST_UPDATE_TS and WRITTEN_TS.

⸻

Core Tables and Queries

1. SCRIPTS (Temporary Table)

This step identifies potential duplicate eRx messages based on PPI Message ID, store number, and written timestamp.
Key logic includes:
	•	Excludes invalid prescription states (RX_STATE NOT IN (2,3,5,7)).
	•	Filters out system-generated and batch records.
	•	Includes only eRx prescriptions (RX_ORIGIN_CD = '3').
	•	Restricts to clean, recent data (IS_DIRTY = 'N', last 7 days).
	•	Excludes PPI Message IDs already logged in the historical table.
	•	Flags duplicates when multiple distinct RX_NBR values exist for the same PPI Message ID and date.

⸻

2. FILLS (Temporary Table)

Enriches duplicate scripts with prescription fill-level details.
Joined with:
	•	RXC_PRESCRIPTION_FILL_RT to capture fill number, NDC, and fill status.
	•	DIM_RX_FILL_STATUS for human-readable fill descriptions.

Filters include:
	•	Excludes reversed or invalid fills (FILL_STATE_CD <> '3', FILL_STATUS_CD <> '0').
	•	Removes OTC drugs and ensures only valid records (DIRTY_IND = 'N').
	•	Keeps the most recent Kafka record per prescription/fill combination.

⸻

3. DUPLICATE_PPI_HIST (Historical Table)

Stores all unique PPI Message IDs identified as duplicates during this run to ensure they are not reprocessed in future cycles.

INSERT INTO DL_RX_OPERATION.RX_OPS_SANDBOX.DUPLICATE_PPI_HIST
SELECT DISTINCT PPI_MESSAGE_ID
FROM FILLS;

This creates a persistent log of duplicate prescription instances across weeks.

⸻

4. STAGED_DATA (Final Output)

Combines the enriched duplicate fill data with patient, drug, and store attributes for review and reporting.
Joins include:
	•	PATIENT for demographics (name, DOB, phone).
	•	DRUG for label and product details.
	•	STORE for state and location information.

The final dataset displays all relevant fields needed for investigation:
	•	PPI_MESSAGE_ID, STORE_NBR, RX_NBR, RXC_PRESCRIPTION_ID
	•	FIRST_NM, LAST_NM, BIRTH_DT, MOBILE_PHONE_NBR
	•	LABEL_NM, STATE_NM, DRUG_SCHEDULE, and FILL_STATUS_CD

Duplicates are confirmed when more than one RX_NBR exists for the same message ID and store within a single day.



